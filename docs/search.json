[{"path":"/articles/my-vignette.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"PRECISION.array Vignette","text":"PRECISION.array package allows users conduct re-sampling-based simulation study molecular classification, using unique pair Agilent microRNA array datasets 1, 2. simulation study illustrate intricate interplay data generation, data preprocessing, classification error estimation molecular classification. offers insights desired practice study design data analysis molecular classification, research sources can optimized generate high-quality molecular data develop reproducible classifiers. document familiarizes users data functions available package. also allows users explore topic using additional normalization classification methods. using PRECISION.array, please cite following papers: Huang HC, Qin LX. PRECISION: R package assessing study design data normalization molecular classification studies using unique pair microarray datasets (2016). GitHub repository, https://github.com/LXQin/PRECISION.array. Qin LX, Huang HC, Begg CB. Cautionary note cross validation molecular classification. Journal Clinical Oncology. 2016, http://ascopubs.org/doi/abs/10.1200/JCO.2016.68.1031.","code":""},{"path":"/articles/my-vignette.html","id":"package-overview","dir":"Articles","previous_headings":"","what":"Package Overview","title":"PRECISION.array Vignette","text":"first step install PRECISION.array CRAN typing following command R console:","code":"if(!require(PRECISION.array)) install.packages(\"PRECISION.array\") library(PRECISION.array)"},{"path":"/articles/my-vignette.html","id":"data-description","dir":"Articles","previous_headings":"","what":"Data Description","title":"PRECISION.array Vignette","text":"Two datasets generated set 96 endometrial 96 ovarian tumor samples using different experimental handling designs. first dataset handled one technician one run arrays randomly assigned tumor samples blocking (array slide, uniformly-handled data). second dataset handled two technicians multiple batches arrays assigned order sample collection (without blocking randomization), mimic typical practice (nonuniformly-handled data). details data collection can found Qin et al.3 datasets publicly available GEO . save time package loading, package includes two example datasets (probe level): uniformly-handled data uhdata.pl nonuniformly-handled data nuhdata.pl, 5% random subset markers original data. glimpse datasets. last character sample labels “E” “V” indicates whether sample endometrial ovarian tumor. load data, simply use commands : Uniformly-handled Data Nonuniformly-handled Data","code":"data(\"uhdata.pl\") data(\"nuhdata.pl\")"},{"path":"/articles/my-vignette.html","id":"probe-selection","dir":"Articles","previous_headings":"","what":"Probe Selection","title":"PRECISION.array Vignette","text":"Initially, number replicates marker/probe varies 10 40. recommend truncating number replicates fixed number across probes save data preprocessing time. confident recommending practice previously observed variation among replicates probe small. , provide per.unipbset.truncate() truncate number replicates data. simulation study, used first 10 replicates unique probe. Agilent platform includes control probes, analyses demonstrated document use non-control probe data. exception batch effects adjusted RUV-4 (explained later section). following code identifies filters control probes data.","code":"## Example of taking only the first 5 replicates for each unique probe uhdata.pl.p5 <- per.unipbset.truncate(data = uhdata.pl,                                       num.per.unipbset = 5) # negative control probes ctrl.genes <- unique(rownames(uhdata.pl))[grep(\"NC\", unique(rownames(uhdata.pl)))]  uhdata.pl.nc <- uhdata.pl[!rownames(uhdata.pl) %in% ctrl.genes, ] # nc for non-control probes"},{"path":"/articles/my-vignette.html","id":"data-simulation","dir":"Articles","previous_headings":"","what":"Data Simulation","title":"PRECISION.array Vignette","text":"used uniformly-handled dataset approximate biological effect sample, difference two arrays (one uniformly-handled dataset nonuniformly-handled dataset) sample approximate handling effect array nonuniformly-handled dataset. done estimate.biological.effect() estimate.handling.effect() follows: 192 samples randomly split 2:1 ratio training set test set, balanced tumor type. 192 arrays non-randomly split training set (n=128, first 64 last 64 arrays order array processing). first 80 arrays profiled one technician rest technician. Next, training set, data simulated “virtual re-hybridization” first assigning arrays sample groups using confounding design balanced design, summing biological effect sample handling effect assigned array. test set, used onlyt biological effect data uniformly-handled dataset. Three study design functions assign arrays samples (confounding.design(), stratification.design(), blocking.design()). Finally, rehybridize() provided sum biological effects handling effects, following array--sample assignments. one possible array--sample-group splits study designs. vertical bar represents array color stripe represents sample group array assigned .  Batch effect correction available re-hybridization step. adjustment can turned specifying icombat = TRUE, isva = TRUE iruv = TRUE ComBat4, sva5, RUV-46; none selected, batch adjustment performed. Note RUV-4 (iruv = TRUE) selected, control-probe data must supplied.","code":"biological.effect <- estimate.biological.effect(uhdata = uhdata.pl)  handling.effect <- estimate.handling.effect(uhdata = uhdata.pl, nuhdata = nuhdata.pl)  biological.effect.nc <- biological.effect[!rownames(biological.effect) %in% ctrl.genes, ] handling.effect.nc <- handling.effect[!rownames(handling.effect) %in% ctrl.genes, ] set.seed(101) group.id <- substr(colnames(biological.effect.nc), 7, 7)  # randomly split biological effect data into training and test set with equal number of endometrial and ovarian samples biological.effect.train.ind <- colnames(biological.effect.nc)[c(sample(which(group.id == \"E\"), size = 64), sample(which(group.id == \"V\"), size = 64))]  biological.effect.test.ind <- colnames(biological.effect.nc)[!colnames(biological.effect.nc) %in% biological.effect.train.ind]  # non-randomly split handling effect data into training and test set handling.effect.train.ind <- colnames(handling.effect.nc)[c(1:64, 129:192)] handling.effect.test.ind <- colnames(handling.effect.nc)[65:128]  group.id.list <- list(\"all\" = group.id,                  \"tr\" = substr(biological.effect.train.ind, 7, 7),                  \"te\" = substr(biological.effect.test.ind, 7, 7)) array.to.sample.assign <- list(\"all\" = c(rep(c(\"E\", \"V\"), each = 64),                                     rep(c(\"V\", \"E\"), each = 32)),                           \"tr\" = rep(c(\"E\", \"V\"), each = 64),                           \"te\" = rep(c(\"V\", \"E\"), each = 32)) # complete confounding cc.ind <- confounding.design(seed = 1, num.array = 128,                                 degree = \"complete\", rev.order = FALSE)  # partial confounding reversed pc.rev.ind <- confounding.design(seed = 2, num.array = 128,                                 degree = \"partial\", rev.order = TRUE)  # stratification batch.id <- list(1:40, 41:64, (129:160) - 64, (161:192) - 64) str.ind <- stratification.design(seed = 3, num.array = 128,                                        batch.id = batch.id)  # blocking blk.ind <- blocking.design(seed = 4, num.array = 128) assign.ind <- confounding.design(seed = 1, num.array = 192,                                 degree = \"complete\", rev.order = FALSE) group.id <- substr(colnames(biological.effect.nc), 7, 7)  # re-hybridize sim.data.raw <- rehybridize(biological.effect = biological.effect.nc,                             handling.effect = handling.effect.nc,                             group.id = group.id,                             array.to.sample.assign = assign.ind)  # re-hybridize + correct batch effects with SVA sim.data.sva <- rehybridize(biological.effect = biological.effect.nc,                             handling.effect = handling.effect.nc,                             group.id = group.id,                             array.to.sample.assign = assign.ind,                              isva = TRUE)  # re-hybridize + correct batch effects with RUV-4 biological.effect.ctrl <- biological.effect[rownames(biological.effect) %in% ctrl.genes, ] handling.effect.ctrl <- handling.effect[rownames(handling.effect) %in% ctrl.genes, ]  sim.data.ruv <- rehybridize(biological.effect = biological.effect.nc,                             handling.effect = handling.effect.nc,                             group.id = group.id,                             array.to.sample.assign = assign.ind,                              iruv = TRUE,                             biological.effect.ctrl = biological.effect.ctrl,                             handling.effect.ctrl = handling.effect.ctrl)"},{"path":"/articles/my-vignette.html","id":"data-preprocessing","dir":"Articles","previous_headings":"","what":"Data Preprocessing","title":"PRECISION.array Vignette","text":"Data preprocessing study includes three steps: log2 transformation; normalization training data frozen normalization test data (, mapping empirical distribution individual test-set sample “frozen” empirical distribution normalized training data); probe-replicate summarization using median. provide med.norm(), quant.norm(), vs.norm() median normalization, quantile normalization7, variance stabilizing normalization8, respectively. summarize replicate level data unique probe level, based within-probe medians, med.sum.pbset() can used:","code":"set.seed(101) group.id <- substr(colnames(sim.data.raw), 7, 7)  # randomly split data into training and test set with equal number of endometrial and ovarian samples train.ind <- colnames(biological.effect)[c(sample(which(group.id == \"E\"), size = 64), sample(which(group.id == \"V\"), size = 64))]  train.dat <- sim.data.raw[, train.ind] test.dat <- sim.data.raw[, !colnames(sim.data.raw) %in% train.ind]   # median normalize (normalize training data only) data.mn1 <- med.norm(train = train.dat)  # median normalize (frozen normalize test data only) data.mn2 <- med.norm(test = test.dat, ref.dis = data.mn1$ref.dis)  # quantile normalize (normalize training data + frozen normalize test data) data.qn <- quant.norm(train = train.dat, test = test.dat)  # varaince stabilizing normalize (normalize training data + frozen normalize test data) data.vsn <- vs.norm(train = train.dat, test = test.dat) uhdata.psl <- med.sum.pbset(data = uhdata.pl, num.per.unipbset = 10)"},{"path":"/articles/my-vignette.html","id":"classifier-development-and-error-estimation","dir":"Articles","previous_headings":"","what":"Classifier Development and Error Estimation","title":"PRECISION.array Vignette","text":"Regardless classification methods, internal cross-validation can used select tuning parameter(s) external validation used validate performance. simulation study, reported results use two classification methods: one non-parametric method (prediction analysis microarrays (PAM)9) one parametric method (least absolute shrinkage selection operator (LASSO)10). Examples model-building predicting functions PRECISION.array pam.intcv() pam.predict() PAM lasso.intcv() lasso.predict() LASSO.","code":"set.seed(101) # randomly split biological effect data into training and test set with equal number of endometrial and ovarian samples biological.effect.train.ind <- colnames(biological.effect.nc)[c(sample(which(group.id == \"E\"), size = 64), sample(which(group.id == \"V\"), size = 64))]  biological.effect.test.ind <- colnames(biological.effect.nc)[!colnames(biological.effect.nc) %in% biological.effect.train.ind]  biological.effect.nc.tr <- biological.effect.nc[, biological.effect.train.ind] biological.effect.nc.te <- biological.effect.nc[, biological.effect.test.ind]  # build a PAM classifier pam.int <- pam.intcv(X = biological.effect.nc.tr,                      y = substr(colnames(biological.effect.nc.tr), 7, 7),                      kfold = 5, seed = 1)  # predict with the PAM classifier pam.pred <- pam.predict(pam.intcv.model = pam.int,                          pred.obj = biological.effect.nc.te,                          pred.obj.group.id = substr(colnames(biological.effect.nc.te), 7, 7))  # cross-validation misclassification error rate pam.int$mc # external validation misclassification error rate pam.pred$mc  # build a LASSO classifier lasso.int <- lasso.intcv(X = biological.effect.nc.tr,                      y = substr(colnames(biological.effect.nc.tr), 7, 7),                      kfold = 5, seed = 1, alp = 1)  # predict with the LASSO classifier lasso.pred <- lasso.predict(lasso.intcv.model = lasso.int,                          pred.obj = biological.effect.nc.te,                          pred.obj.group.id = substr(colnames(biological.effect.nc.te), 7, 7))  # cross-validation misclassification error rate lasso.int$mc # external validation misclassification error rate lasso.pred$mc"},{"path":"/articles/my-vignette.html","id":"wrapper-functions-for-running-simulations","dir":"Articles","previous_headings":"","what":"Wrapper Functions for Running Simulations","title":"PRECISION.array Vignette","text":"Finally, main functionality PRECISION.array provide users efficient way reproduce simulation studies reported JCO press. Two wrapper functions available : one analysis uniformly-handled data analysis data confounding handling (.e. analysis simulated data)","code":""},{"path":"/articles/my-vignette.html","id":"analysis-of-the-uniformly-handled-data","dir":"Articles","previous_headings":"Wrapper Functions for Running Simulations","what":"Analysis of the uniformly-handled data","title":"PRECISION.array Vignette","text":"analysis uniformly-handled data based N splits training--test-set uniformly-handled data; uni.handled.simulate() used. Users can manipulate signal level estimated biological effects choose method data normalization classification. Analysis uniformly-handled data","code":"uni.handled.results <- uni.handled.simulate(seed = 1, N = 3,                                             biological.effect = biological.effect.nc,                                             norm.list = c(\"NN\", \"QN\"),                                             class.list = c(\"PAM\", \"LASSO\")) knitr::kable(data.frame(uni.handled.results$error_store[2, ]),               caption = \"Analysis of uniformly-handled data\")"},{"path":"/articles/my-vignette.html","id":"analysis-with-confounding-handling","dir":"Articles","previous_headings":"Wrapper Functions for Running Simulations","what":"Analysis with confounding handling","title":"PRECISION.array Vignette","text":"analysis data confounding handling based N array--sample reassignments using precision.simulate(). Users can control signal level estimated biological effects, confounding level estimated handling effects, array--sample study design, normalization method, batch adjustment method, classification methods. Analysis simulated data presence confounding handling Analysis simulated data presence confounding handling, adjusting batch effects RUV-4","code":"set.seed(101) group.id <- substr(colnames(biological.effect.nc), 7, 7)  # randomly split biological effect data into training and test set with equal number of endometrial and ovarian samples biological.effect.train.ind <- colnames(biological.effect.nc)[c(sample(which(group.id == \"E\"), size = 64), sample(which(group.id == \"V\"), size = 64))]  biological.effect.test.ind <- colnames(biological.effect.nc)[!colnames(biological.effect.nc) %in% biological.effect.train.ind]  biological.effect.train.test.split =   list(\"tr\" = biological.effect.train.ind,        \"te\" = biological.effect.test.ind)  # non-randomly split handling effect data into training and test set; technician effect as proxy handling.effect.train.test.split =   list(\"tr\" = c(1:64, 129:192),        \"te\" = 65:128)  biological.effect.nc.tr <- biological.effect.nc[, biological.effect.train.ind] biological.effect.nc.te <- biological.effect.nc[, biological.effect.test.ind] handling.effect.nc.tr <- handling.effect.nc[, c(1:64, 129:192)] handling.effect.nc.te <- handling.effect.nc[, 65:128]  # simulation without batch adjustment precision.results <- precision.simulate(seed = 1, N = 3,                           biological.effect.tr = biological.effect.nc.tr,                               biological.effect.te = biological.effect.nc.te,                           handling.effect.tr = handling.effect.nc.tr,                           handling.effect.te = handling.effect.nc.te,                           group.id.tr = substr(colnames(biological.effect.nc.tr), 7, 7),                           group.id.te = substr(colnames(biological.effect.nc.te), 7, 7),                           design.list = c(\"PC-\", \"STR\"),                           norm.list = c(\"NN\", \"QN\"),                           class.list = c(\"PAM\", \"LASSO\"),                           batch.id = list(1:40, 41:64, (129:160) - 64, (161:192) - 64))  # simulation with RUV-4 batch adjustment #   (bringing in control-probe data) biological.effect.tr.ctrl <- biological.effect.ctrl[, biological.effect.train.test.split$tr] handling.effect.tr.ctrl <- handling.effect.ctrl[, handling.effect.train.test.split$tr]  precision.ruv4.results <- precision.simulate(seed = 1, N = 3,                               biological.effect.tr = biological.effect.nc.tr,                                   biological.effect.te = biological.effect.nc.te,                               handling.effect.tr = handling.effect.nc.tr,                               handling.effect.te = handling.effect.nc.te,                               group.id.tr = substr(colnames(biological.effect.nc.tr), 7, 7),                               group.id.te = substr(colnames(biological.effect.nc.te), 7, 7),                               design.list = c(\"PC-\", \"STR\"),                               norm.list = c(\"NN\", \"QN\"),                               class.list = c(\"PAM\", \"LASSO\"),                               batch.id = list(1:40, 41:64, (129:160) - 64, (161:192) - 64),                                iruv = TRUE,                               biological.effect.tr.ctrl = biological.effect.tr.ctrl,                                handling.effect.tr.ctrl = handling.effect.tr.ctrl) knitr::kable(data.frame(precision.results$error_store[2, \"PC-\"]),               aligh = \"l\",              caption = \"Analysis of simulated data in presence of confounding handling\") knitr::kable(data.frame(precision.ruv4.results$error_store[2, \"PC-\"]),               aligh = \"l\",              caption = \"Analysis of simulated data in presence of confounding handling, adjusting batch effects with RUV-4\")"},{"path":"/articles/my-vignette.html","id":"additional-simulation-scenarios","dir":"Articles","previous_headings":"","what":"Additional Simulation Scenarios","title":"PRECISION.array Vignette","text":"uni.handled.simulate() precision.simulate() allows user-defined function normalization classification method comparison purposes. user-defined normalization method function must allow least two input parameters: train test (test can NULL). user required provide short name normalization method use short name (lower case) defining output. example, short name “RN”, function must return list two outputs: train.rn test.frn normalized training frozen-normalized test. Analysis uniformly-handled data (RN) user-defined classification method, user must provide two functions: one building model one predicting. build function must allow input parameters kfold, X, y, seed, must return list outputs minimum including mc, model (naming must match). predict function must allow three input parameters build model, object predicted, group ID object predicted (note: order matters). Lastly, predict function must return list outputs minimum including mc misclassification error rate (naming must match). required highly recommended return predicted probabilities selected features future uses. Analysis uniformly-handled data (Ridge)","code":"# an example of user-defined normalization method function:  # rand.norm() randomly shuffles the sample IDs \"rand.norm\" <- function(train, test = NULL){   stopifnot(nrow(train) == nrow(test))      if(is.null(test)) {     test.frn <- NULL   } else{     train.rn <- apply(train, 2, sample)     dimnames(train.rn) <- dimnames(train)          test.frn <- apply(test, 2, sample)     dimnames(test.frn) <- dimnames(test)   }      return(list(\"train.rn\" = train.rn,               \"test.frn\" = test.frn)) }  uni.handled.results.rn <- uni.handled.simulate(seed = 1, N = 3,                                        biological.effect = biological.effect.nc,                                        norm.list = c(\"NN\", \"QN\", \"RN\"),                                        class.list = c(\"PAM\", \"LASSO\"),                                         norm.funcs = \"rand.norm\") knitr::kable(data.frame(uni.handled.results.rn$error_store[2, ]),               caption = \"Analysis of uniformly-handled data (with RN)\") # example of user-defined classification method functions: \"build.ridge\" <- function(kfold = 5, X, y, seed, alp = 0){   ptm <- proc.time()   set.seed(seed)      cv.fit <- glmnet::cv.glmnet(x = data.matrix(t(X)), y = factor(y),                               family = \"binomial\", type.measure = \"class\",                                alpha = alp, nfold = kfold)      mc <- cv.fit$cvm[which(cv.fit$lambda == cv.fit$lambda.1se)]      coefs <- coef(cv.fit, s = \"lambda.1se\")   time <- proc.time() - ptm   return(list(mc=mc, time=time, model=cv.fit, cfs=coefs)) }  # ridge has the same prediction function as LASSO  uni.handled.results.ridge <- uni.handled.simulate(seed = 1, N = 3,                                    biological.effect = biological.effect.nc,                                    norm.list = c(\"NN\", \"RN\"),                                    class.list = c(\"LASSO\", \"Ridge\"),                                     norm.funcs = \"rand.norm\",                                    class.funcs = \"build.ridge\",                                     pred.funcs = \"lasso.predict\") knitr::kable(data.frame(uni.handled.results.ridge$error_store[2, ]),               caption = \"Analysis of uniformly-handled data (with Ridge)\")"},{"path":"/articles/my-vignette.html","id":"simulation-result-manipulation-and-visualization","dir":"Articles","previous_headings":"","what":"Simulation Result Manipulation and Visualization","title":"PRECISION.array Vignette","text":"PRECISION.array output R objects resulted precision.simulate() can tidied list data frames extract.precision.error(). list data frames easier manipulate. plotting function plot.precision() offered quick visualization simulation results.","code":"# for outputs from either precision.simulate() or precision.simulate.flex() precision.err.df <- extract.precision.error(   precision.obj.name = \"precision.results\")  # for PRECISION output from precision.simulate() plot.precision(data = precision.err.df, iflex = FALSE,                 mytitle = \"PRECISION results (misclassification error rate)\") # for PRECISION output from precision.simulate.flex() plot.precision(data = precision.results.flex)"},{"path":"/articles/my-vignette.html","id":"differential-expression-analysis","dir":"Articles","previous_headings":"Simulation Result Manipulation and Visualization","what":"Differential expression analysis","title":"PRECISION.array Vignette","text":"provide limma.pbset perform differential expression analysis. instance, reducing biological signal, first identified differentially expressed markers shrunk sample group differences markers.","code":"uhdata.psl.nc <- uhdata.psl[!rownames(uhdata.psl) %in% ctrl.genes, ] # nc for non-control probes  group.id <- substr(colnames(uhdata.psl.nc), 7, 7) group.id.level <- levels(as.factor(group.id)) limma.fit.uhdata<- limma.pbset(data = uhdata.psl.nc,                                 group.id = group.id,                                group.id.level = group.id.level) table(limma.fit.uhdata$P.Value < 0.01, dnn = \"DE genes\") tab <- data.frame(table(limma.fit.uhdata$P.Value < 0.01)) colnames(tab) <- c(\"DEA\", \"Count\") knitr::kable(tab, rownames = NULL)"},{"path":"/articles/my-vignette.html","id":"biological-signal-reduction","dir":"Articles","previous_headings":"Simulation Result Manipulation and Visualization","what":"Biological signal reduction","title":"PRECISION.array Vignette","text":"may necessary manipulate level biological signal (.e., mean group difference sample group) molecular classification study. manipulate level signal, reduce.signal() can used.","code":"# reduced signal by half group.id <- substr(colnames(biological.effect.nc), 7, 7) redhalf.biological.effect.nc <- reduce.signal(biological.effect = biological.effect.nc,                             group.id = group.id,                             group.id.level = c(\"E\", \"V\"),                             reduce.multiplier = 1/2)   # extract differential expressed genes biological.effect.nc.psl <- med.sum.pbset(biological.effect.nc) s.e.limma.fit <- limma.pbset(data = biological.effect.nc.psl,                          group.id = group.id,                          group.id.level = c(\"E\", \"V\")) de.ind <- s.e.limma.fit$P.Value < 0.01  de.gene.name <- rownames(redhalf.biological.effect.nc)[which(de.ind)][2] nonde.gene.name <- rownames(redhalf.biological.effect.nc)[-which(de.ind)][2]  biological.effect.nc.de <- biological.effect.nc[de.gene.name, ] redhalf.biological.effect.nc.de <- redhalf.biological.effect.nc[de.gene.name, ]  biological.effect.nc.nonde <- biological.effect.nc[nonde.gene.name, ] redhalf.biological.effect.nc.nonde <- redhalf.biological.effect.nc[nonde.gene.name, ]"},{"path":"/articles/my-vignette.html","id":"handling-effect-amplification","dir":"Articles","previous_headings":"Simulation Result Manipulation and Visualization","what":"Handling effect amplification","title":"PRECISION.array Vignette","text":", may necessary manipulate confounding level handling effects simulation study order evaluate normalization classification methods presence handling effect. offer three amplification methods amplify.handling.effect(): location shift - per selected array, shifting probe expressions constant. scale change 1 - per selected array, expanding variance probes towards array’s inter-quartiles; probes outside inter-quartiles remain unchanged. scale change 2 - scaling probe expressions arrays power constants different batch. training data, four batches.","code":"handling.effect.nc.tr <- handling.effect.nc[, c(1:64, 129:192)]  # location shift handling.effect.nc.tr.shift <- amplify.handling.effect(handling.effect = handling.effect.nc.tr,        amplify.array.id = colnames(handling.effect.nc.tr)[1:64],        amplify.level = 2, type = \"shift\")  # scale change 1 handling.effect.nc.tr.scale1 <- amplify.handling.effect(handling.effect = handling.effect.nc.tr,        amplify.array.id = colnames(handling.effect.nc.tr)[1:64],        amplify.level = 2, type = \"scale1\")  # scale change 2 amplify.array.id <- list(1:40, 41:64, (129:160) - 64, (161:192) - 64) for(i in 1:length(amplify.array.id))    amplify.array.id[[i]] <- colnames(handling.effect.nc.tr)[amplify.array.id[[i]]] amplify.level <- c(1.2, 1.3, 1/3, 2/3)  handling.effect.nc.tr.scale2 <- amplify.handling.effect(handling.effect = handling.effect.nc.tr,        amplify.array.id = amplify.array.id,        amplify.level = amplify.level,        type = \"scale2\")  par(mfrow = c(2, 2), mar = c(2, 2, 2, 1)) rng <- range(handling.effect.nc.tr, handling.effect.nc.tr.shift,               handling.effect.nc.tr.scale1, handling.effect.nc.tr.scale2) boxplot(handling.effect.nc.tr, main = \"Original\",         ylim = rng, pch = 20, cex = 0.2, xaxt = \"n\") boxplot(handling.effect.nc.tr.shift, main = \"Shift\",         ylim = rng, pch = 20, cex = 0.2, xaxt = \"n\") boxplot(handling.effect.nc.tr.scale1, main = \"Scaling 1\",         ylim = rng, pch = 20, cex = 0.2, xaxt = \"n\") boxplot(handling.effect.nc.tr.scale2, main = \"Scaling 2\",         ylim = rng, pch = 20, cex = 0.2, xaxt = \"n\")"},{"path":"/articles/my-vignette.html","id":"different-study-design-methods-and-normalization-methods-on-training-and-test-sets","dir":"Articles","previous_headings":"","what":"Different Study Design Methods and Normalization Methods on Training and Test Sets","title":"PRECISION.array Vignette","text":"Furthermore, care cooeperative effects different study design methods normalization methods, separately training test sets. function precision.simulate.class(), built upon precision.simulate() , can apply different study design methods normalization methods training set test set, fit kinds classifiers training set predict test set. built-designs “NONE”, CC+“,”CC-“,”PC+“,”PC-“,”BLK“, ”STR\" “Rehybridization”, “Complete Confounding 1”, “Complete Confounding 2”, “Partial Confounding 1”, “Partial Confounding 2”, “Blocking”, “Stratification” Qin et al. Study design methods training set: {“NONE”, “CC+”, “CC-”, “PC+”, “PC-”, “BLK”, “STR”}; Study design methods test set: {“NONE”, “CC+”, “CC-”, “PC+”, “PC-”, “BLK”, “STR”}; build-available normalization methods “NN”, “MN”, “QN”, “fMN”, “fQN”, “pMN”, “pQN”, “fVSN”, “Normalization”, “Median Normalization”, “Quantile Normalization”, “Frozen Median Normalization”, “Frozen Quantile Normalization”, “Pool Median Normalization”, “Pool Quantile Normalization”, “Frozen Vairance Stability Normalization”. Normalization methods training set: {“NN”, “MN”, “QN”, “VSN”}; Normalization methods test set: {“NN”, “MN”, “QN”, “fMN”, “fQN”, “pMN”, “pQN”, “VSN”, “fVSN”} build-available classfication methods “PAM”, “LASSO”, “ClaNC”, “ranFor”, “SVM”, “kNN” “DLDA”, “Prediction Analysis Microarrays”, “Least Absolute Shrinkage Selection Operator”, “Classification Nearest Centroids”, “Random Forest”, “Support Vector Machine”, “K-Nearest Neighbors” “Diagonal Linear Discriminant”. can also use classification method setting  “custom”. format create custom.intcv custom.predict please refers classification methods package. Classifiers: {“PAM”, “LASSO”, “ClaNC”, “ranFor”, “SVM”, “kNN”, “DLDA”, “custom”} Choose objective methods express train.design.met, test.design.met, train.norm.met, test.norm.met class.met. output structure one set methods similar aforementioned precision.simulate()， one list called ari_store, contains adjusted rand index test set. precision.simulate.class sample error output save time calculation, additional function called precision.simulate.multiclass(). replaces class.met, can input one classification, class.list, can calculate several different classifications combination study design methods normalization methods. precision.simulate.multiclass sample error output can use plot.precision.multiclass() plot average enternal error rates output precision.simulate.multiclass().  want use classification, please create function called custom.intcv() model fitting one called custom.predict() model prediction. example create SVM classification specific parameters.","code":"precision.class.results <- precision.simulate.class(seed = 0, N = 3,                           biological.effect.tr = biological.effect.nc.tr,                               biological.effect.te = biological.effect.nc.te,                           handling.effect.tr = handling.effect.nc.tr,                           handling.effect.te = handling.effect.nc.te,                           group.id.tr = substr(colnames(biological.effect.nc.tr), 7, 7),                           group.id.te = substr(colnames(biological.effect.nc.te), 7, 7),                           train.design.met = \"PC+\",                           test.design.met = \"STR\",                           train.norm.met = \"QN\",                           test.norm.met = \"fQN\",                           class.met = \"ClaNC\",                           train.batch.id = list(1:40, 41:64, (129:160) - 64, (161:192) - 64),                           test.batch.id = list(1:32, 33:64)) precision.multiclass.results <- precision.simulate.multiclass(seed = 0, N = 3,                           biological.effect.tr = biological.effect.nc.tr,                               biological.effect.te = biological.effect.nc.te,                           handling.effect.tr = handling.effect.nc.tr,                           handling.effect.te = handling.effect.nc.te,                           group.id.tr = substr(colnames(biological.effect.nc.tr), 7, 7),                           group.id.te = substr(colnames(biological.effect.nc.te), 7, 7),                           train.design.met = \"PC+\",                           test.design.met = \"STR\",                           train.norm.met = \"QN\",                           test.norm.met = \"fQN\",                           class.list = c(\"SVM\", \"kNN\", \"ClaNC\"),                           train.batch.id = list(1:40, 41:64, (129:160) - 64, (161:192) - 64),                           test.batch.id = list(1:32, 33:64)) plot.precision.multiclass(data = precision.multiclass.results,                           mytitle = \"Average external error rates\",                           class.order = c(\"SVM\", \"kNN\", \"ClaNC\"),                           ylim = c(0,0.5),                           save.name = NULL) library(e1071)  \"custom.intcv\" <- function(kfold = 10, X, y, seed){   ptm <- proc.time()   set.seed(seed)    svm_tune = tune.svm(x = data.matrix(t(X)), y = factor(y), cost = 10^(-2:2), gamma = c(0.01, 0.1, 1), tunecontrol = tune.control(cross = kfold))    time <- proc.time() - ptm   return(list(mc = svm_tune$best.performance, time = time, model = svm_tune$best.model)) }  \"custom.predict\" <- function(custom.intcv.model, pred.obj, pred.obj.group.id){    pred <- predict(custom.intcv.model$model, newdata = t(pred.obj))   mc <- tabulate.ext.err.func(pred, pred.obj.group.id)    return(list(pred=pred, mc=mc)) }"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Huei-Chung Huang. Maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Huang H, Qin L, Yang Q, Wu Y (2022). PRECISION.array: PaiREd miCrorna sImulation Study desIgn mOlecular classificatioN. R package version 0.1.0, http://clincancerres.aacrjournals.org/content/20/13/3371.long.","code":"@Manual{,   title = {PRECISION.array: PaiREd miCrorna sImulation on Study desIgn for mOlecular classificatioN},   author = {Huei-Chung Huang and Li-Xuan Qin and Qihang Yang and Yilin Wu},   year = {2022},   note = {R package version 0.1.0},   url = {http://clincancerres.aacrjournals.org/content/20/13/3371.long}, }"},{"path":"/index.html","id":"precisionarray-v010","dir":"","previous_headings":"","what":"PaiREd miCrorna sImulation on Study desIgn for mOlecular\n        classificatioN","title":"PaiREd miCrorna sImulation on Study desIgn for mOlecular\n        classificatioN","text":"propose new R package PRECISION.array provides pipeline resampling-based data simulation, data normalization, classifier development microRNA microarrays. package offers two study designs simulating data via process dubbed ‘virtual rehybridization’ (confounding design stratified design), three methods normalizing training data (median normalization, quantile normalization, variance stabilizing normalization), seven methods normalizing test data (median normalization, frozen median normalization, quantile normalization, frozen quantile normalization, pooled quantile normalization, variance stabilizing normalization, frozen variance stabilizing normalization), seven methods building sample classifier (LASSO, PAM, ClaNC, DLDA, kNN, SVM, Random Forest). package can used study performance various study designs microarray data generation various methods data normalization sample classification, connection . full pipelines normalization classification provided wrapper functions precision.simulate(), precision.simulate.class(), precision.simulate.multiclass(). package can installed R:","code":"devtools::install_github(\"LXQin/PRECISION.array\")"},{"path":"/index.html","id":"reference","dir":"","previous_headings":"","what":"REFERENCE","title":"PaiREd miCrorna sImulation on Study desIgn for mOlecular\n        classificatioN","text":"[2]: Huang HC, Qin LX. PRECISION: R package assessing study design data normalization molecular classification studies using unique pair microarray datasets (2016). GitHub repository, https://github.com/LXQin/PRECISION.array. https://ascopubs.org/doi/full/10.1200/PO.21.00103","code":""},{"path":"/reference/amplify.handling.effect.html","id":null,"dir":"Reference","previous_headings":"","what":"Handling effect amplification — amplify.handling.effect","title":"Handling effect amplification — amplify.handling.effect","text":"Amplify handling effect pre-specified slides either location shift scale change.","code":""},{"path":"/reference/amplify.handling.effect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Handling effect amplification — amplify.handling.effect","text":"","code":"amplify.handling.effect(   handling.effect,   amplify.array.id,   amplify.level,   type = \"shift\" )"},{"path":"/reference/amplify.handling.effect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Handling effect amplification — amplify.handling.effect","text":"handling.effect estimated handling effect dataset modified. dataset must rows probes columns samples. amplify.array.id array IDs specified handling effect amplified. type = \"shift\" type = \"scale1\", vector array IDs must supplied. type = \"scale2\", list vectors array IDs must supplied; element list must vector array IDs. amplify.level multiplier specified amplify handling effect . numeric multiplier must supplied type = \"shift\" type = \"scale1\". vector multipliers must supplied type = \"scale2\" must equal length amplify.array.id list. type choice amplification type, either \"shift\", \"scale1\" \"scale2\" either location shift scale change. default, type = \"shift\". Location shift moves entire specified arrays constant. Scale change 1 re-scales expressions inter-quartiles towards first third quartiles Within array; expressions outside inter-quartile range remain unchanged. Scale change 2 re-scales expressions power constants specified user batch.","code":""},{"path":"/reference/amplify.handling.effect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Handling effect amplification — amplify.handling.effect","text":"handling-effect-amplified set handling effects","code":""},{"path":"/reference/amplify.handling.effect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Handling effect amplification — amplify.handling.effect","text":"","code":"if (FALSE) { biological.effect <- estimate.biological.effect(uhdata = uhdata.pl) handling.effect <- estimate.handling.effect(uhdata = uhdata.pl,                             nuhdata = nuhdata.pl)  ctrl.genes <- unique(rownames(uhdata.pl))[grep(\"NC\", unique(rownames(uhdata.pl)))]  biological.effect.nc <- biological.effect[!rownames(biological.effect) %in% ctrl.genes, ] handling.effect.nc <- handling.effect[!rownames(handling.effect) %in% ctrl.genes, ]  handling.effect.nc.tr <- handling.effect.nc[, c(1:64, 129:192)]  # location shift handling.effect.nc.tr.shift <- amplify.handling.effect(handling.effect = handling.effect.nc.tr,                                        amplify.array.id = colnames(handling.effect.nc.tr)[1:64],                                        amplify.level = 2, type = \"shift\")  # scale change 1 handling.effect.nc.tr.scale1 <- amplify.handling.effect(handling.effect = handling.effect.nc.tr,                                         amplify.array.id = colnames(handling.effect.nc.tr)[1:64],                                         amplify.level = 2, type = \"scale1\")  # scale change 2 amplify.array.id <- list(1:40, 41:64, (129:160) - 64, (161:192) - 64) for(i in 1:length(amplify.array.id))   amplify.array.id[[i]] <- colnames(handling.effect.nc.tr)[amplify.array.id[[i]]] amplify.level <- c(1.2, 1.3, 1/3, 2/3)  handling.effect.nc.tr.scale2 <- amplify.handling.effect(handling.effect = handling.effect.nc.tr,                                         amplify.array.id = amplify.array.id,                                         amplify.level = amplify.level,                                         type = \"scale2\")   par(mfrow = c(2, 2), mar = c(4, 3, 2, 2)) rng <- range(handling.effect.nc.tr, handling.effect.nc.tr.shift,              handling.effect.nc.tr.scale1, handling.effect.nc.tr.scale2) boxplot(handling.effect.nc.tr, main = \"original\",         ylim = rng, pch = 20, cex = 0.2, xaxt = \"n\") boxplot(handling.effect.nc.tr.shift, main = \"shifted\",         ylim = rng, pch = 20, cex = 0.2, xaxt = \"n\") boxplot(handling.effect.nc.tr.scale1, main = \"scaled 1\",         ylim = rng, pch = 20, cex = 0.2, xaxt = \"n\") boxplot(handling.effect.nc.tr.scale2, main = \"scaled 2\",         ylim = rng, pch = 20, cex = 0.2, xaxt = \"n\") }"},{"path":"/reference/blocking.design.html","id":null,"dir":"Reference","previous_headings":"","what":"Blocking Design — blocking.design","title":"Blocking Design — blocking.design","text":"Assign arrays samples blocking experimental design array slide. example Agilent comes eight-plex design. number arrays array slide eight; within array slide, equal number arrays assigned either sample group.","code":""},{"path":"/reference/blocking.design.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Blocking Design — blocking.design","text":"","code":"blocking.design(seed, num.per.slide = 8, num.array)"},{"path":"/reference/blocking.design.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Blocking Design — blocking.design","text":"seed integer used initialize pseudorandom number generator. num.per.slide number arrays per array slide. must multiple 2. default, num.per.slide = 8 Agilent microarrays. num.array number arrays. must multiple num.per.slide.","code":""},{"path":"/reference/blocking.design.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Blocking Design — blocking.design","text":"vector array IDs order assigning samples assumed sorted sample group interest result, first half array IDs assigned sample group 1 second half array IDs assigned sample group 2.","code":""},{"path":"/reference/blocking.design.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Blocking Design — blocking.design","text":"","code":"blocking.design(seed = 1, num.per.slide = 8, num.array = 128) #>   [1]  15  80  76  17  39  71  29 126  53  92 110  46  94  38 128  60 114  48 #>  [19]  97  49  81  67  41  57  79 113  19 111  37  50  63  64  84  11  95 118 #>  [37]   4  24   1 123  30  55  31  82  21  88  10  66   8  78  89 107 103 124 #>  [55] 106   2 102  13  98  33  26  70  45 117  91  69 101  87  99  83 100 112 #>  [73] 108 120 116  93  54  14 105  40  47  32  36  72   5   3  75 119  25  52 #>  [91]  68 121 127  34  74  22  61   6  62  27  90  77  65 115  16  18  35  20 #> [109]  28   9  56 122 109  43 104  23  58  12   7  73  86  59  96  85  42 125 #> [127]  51  44"},{"path":"/reference/calc.confounding.level.html","id":null,"dir":"Reference","previous_headings":"","what":"Level of confounding calculation — calc.confounding.level","title":"Level of confounding calculation — calc.confounding.level","text":"Calculate level confounding handling effects sample group interest dataset. First, principal component applied non-biological subset data. first five principal components used build simple linear regression model predict sample group. highest adjusted R-squared returned level confounding.","code":""},{"path":"/reference/calc.confounding.level.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Level of confounding calculation — calc.confounding.level","text":"","code":"calc.confounding.level(data, group.id, nbe.genes)"},{"path":"/reference/calc.confounding.level.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Level of confounding calculation — calc.confounding.level","text":"data microarry dataset. must rows probes columns samples. group.id vector sample-group labels sample dataset. nbe.genes vector non-biological genes used filter dataset. Non-biological genes indicated TRUE, otherwise FALSE. vector must equal length number probes dataset.","code":""},{"path":"/reference/calc.confounding.level.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Level of confounding calculation — calc.confounding.level","text":"list two elements: locc level confounding k_pc correlated principal component non-biological genes dataset sample group","code":""},{"path":"/reference/calc.confounding.level.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Level of confounding calculation — calc.confounding.level","text":"Leek J., Scharpf R., Bravo H., et al. Tackling widespread critical impact batch effects high-throughput data. Nat Rev Genet 11:733-9, 2010.","code":""},{"path":"/reference/calc.confounding.level.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Level of confounding calculation — calc.confounding.level","text":"","code":"if (FALSE) { biological.effect <- estimate.biological.effect(uhdata = uhdata.pl) handling.effect <- estimate.handling.effect(uhdata = uhdata.pl,                              nuhdata = nuhdata.pl)  ctrl.genes <- unique(rownames(uhdata.pl))[grep(\"NC\", unique(rownames(uhdata.pl)))]  biological.effect.nc <- biological.effect[!rownames(biological.effect)   %in% ctrl.genes, ] handling.effect.nc <- handling.effect[!rownames(handling.effect) %in% ctrl.genes, ]  group.id <- substr(colnames(biological.effect.nc), 7, 7)  biological.effect.train.ind <- colnames(biological.effect.nc)[c(sample(which(   group.id == \"E\"), size = 64), sample(which(group.id == \"V\"), size = 64))] handling.effect.train.ind <- colnames(handling.effect.nc)[c(1:64, 129:192)]  # randomly created a vector of Boolean for nbe.genes nbe.genes <- sample(c(TRUE, FALSE), size = nrow(biological.effect.nc), replace = TRUE)  calc.confounding.level(data = biological.effect.nc[, biological.effect.train.ind],                        group.id = substr(biological.effect.train.ind, 7, 7),                        nbe.genes = nbe.genes) }"},{"path":"/reference/clanc.intcv.html","id":null,"dir":"Reference","previous_headings":"","what":"Classification to Nearest Centroids  Classifier — clanc.intcv","title":"Classification to Nearest Centroids  Classifier — clanc.intcv","text":"Build Classification Nearest Centroids classifier objective data.","code":""},{"path":"/reference/clanc.intcv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Classification to Nearest Centroids  Classifier — clanc.intcv","text":"","code":"clanc.intcv(kfold = 5, X, y, seed)"},{"path":"/reference/clanc.intcv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Classification to Nearest Centroids  Classifier — clanc.intcv","text":"kfold number folds. default, kfold = 5. X dataset trained. dataset must rows probes columns samples. y vector sample group sample dataset trained. must equal length number samples X. seed integer used initialize pseudorandom number generator.","code":""},{"path":"/reference/clanc.intcv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Classification to Nearest Centroids  Classifier — clanc.intcv","text":"list 4 elements: mc internal misclassification error rate time processing time performing internal validation ClaNC model ClaNC classifier, resulted cv.fit","code":""},{"path":"/reference/clanc.intcv.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Classification to Nearest Centroids  Classifier — clanc.intcv","text":"Alan R. Dabney, Author Notes.(2005) ClaNC: point--click software classifying microarrays nearest centroids, https://academic.oup.com/bioinformatics/article/22/1/122/219377","code":""},{"path":"/reference/clanc.intcv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Classification to Nearest Centroids  Classifier — clanc.intcv","text":"","code":"set.seed(101) biological.effect <- estimate.biological.effect(uhdata = uhdata.pl) ctrl.genes <- unique(rownames(uhdata.pl))[grep(\"NC\", unique(rownames(uhdata.pl)))] biological.effect.nc <- biological.effect[!rownames(biological.effect)   %in% ctrl.genes, ] group.id <- substr(colnames(biological.effect.nc), 7, 7)  biological.effect.train.ind <- colnames(biological.effect.nc)[c(sample(which(   group.id == \"E\"), size = 64),   sample(which(group.id == \"V\"), size = 64))] biological.effect.nc.tr <- biological.effect.nc[, biological.effect.train.ind]  clanc.int <- clanc.intcv(X = biological.effect.nc.tr,                      y = substr(colnames(biological.effect.nc.tr), 7, 7),                      kfold = 5, seed = 1) #> CV:12345"},{"path":"/reference/clanc.predict.html","id":null,"dir":"Reference","previous_headings":"","what":"Prediction with Classification to Nearest Centroids classifier — clanc.predict","title":"Prediction with Classification to Nearest Centroids classifier — clanc.predict","text":"Predict Classification Nearest Centroids classifier fit.","code":""},{"path":"/reference/clanc.predict.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prediction with Classification to Nearest Centroids classifier — clanc.predict","text":"","code":"clanc.predict(clanc.intcv.model, pred.obj, pred.obj.group.id)"},{"path":"/reference/clanc.predict.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prediction with Classification to Nearest Centroids classifier — clanc.predict","text":"clanc.intcv.model Classification Nearest Centroids classifier built clanc.intcv. pred.obj dataset sample group predicted. dataset must rows probes columns samples. must equal number probes dataset trained. pred.obj.group.id vector sample-group labels sample dataset predicted. must equal length number samples pred.obj.","code":""},{"path":"/reference/clanc.predict.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prediction with Classification to Nearest Centroids classifier — clanc.predict","text":"list 3 elements: pred predicted sample group sample mc predicted misclassification error rate (external validation) prob predicted probability sample","code":""},{"path":"/reference/clanc.predict.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Prediction with Classification to Nearest Centroids classifier — clanc.predict","text":"Alan R. Dabney, Author Notes.(2005) ClaNC: point--click software classifying microarrays nearest centroids, https://academic.oup.com/bioinformatics/article/22/1/122/219377","code":""},{"path":"/reference/clanc.predict.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prediction with Classification to Nearest Centroids classifier — clanc.predict","text":"","code":"set.seed(101) biological.effect <- estimate.biological.effect(uhdata = uhdata.pl) ctrl.genes <- unique(rownames(uhdata.pl))[grep(\"NC\", unique(rownames(uhdata.pl)))] biological.effect.nc <- biological.effect[!rownames(biological.effect) %in% ctrl.genes, ] group.id <- substr(colnames(biological.effect.nc), 7, 7)  biological.effect.train.ind <- colnames(biological.effect.nc)[c(sample(which(group.id == \"E\"), size = 64),                                           sample(which(group.id == \"V\"), size = 64))] biological.effect.test.ind <- colnames(biological.effect.nc)[!colnames(biological.effect.nc) %in% biological.effect.train.ind]  biological.effect.nc.tr <- biological.effect.nc[, biological.effect.train.ind] biological.effect.nc.te <- biological.effect.nc[, biological.effect.test.ind]  clanc.int <- clanc.intcv(X = biological.effect.nc.tr,                          y = substr(colnames(biological.effect.nc.tr), 7, 7),                         kfold = 5, seed = 1) #> CV:12345  clanc.pred <- clanc.predict(clanc.intcv.model = clanc.int,                            pred.obj = biological.effect.nc.te,                            pred.obj.group.id = substr(colnames(biological.effect.nc.te), 7, 7)) clanc.int$mc #> [1] 0.1796875 clanc.pred$mc #> [1] 0.15625"},{"path":"/reference/confounding.design.html","id":null,"dir":"Reference","previous_headings":"","what":"Confounding Design — confounding.design","title":"Confounding Design — confounding.design","text":"Assign arrays samples confounding experimental design, intentionally assigning arrays sample groups order array collection. Since split nonuniformly-handled training dataset particular way earlier arrays processed one technician later arrays , assigning earlier arrays one sample group later arrays another results confounding handling effects sample groups.","code":""},{"path":"/reference/confounding.design.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Confounding Design — confounding.design","text":"","code":"confounding.design(seed, num.array, degree = \"complete\", rev.order = FALSE)"},{"path":"/reference/confounding.design.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Confounding Design — confounding.design","text":"seed integer used initialize pseudorandom number generator. num.array number arrays. degree level confounding. must either \"complete\" \"partial\" complete confounding design partial confounding design, correspondingly. default, degree = \"complete\". rev.order whether array--sample-group assignment flipped. Originally, first half arrays designated assigned sample group 1 (endometrial sample group) second half sample group 2 (ovarian sample group). array--sample-group assignment flipped (rev.order = TRUE), first half array IDs swapped second half array IDs. default, rev.order = FALSE.","code":""},{"path":"/reference/confounding.design.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Confounding Design — confounding.design","text":"vector array IDs order assigning samples assumed sorted sample group interest (first half samples belong sample group 1 second half sample group 2). result, first half array IDs assigned sample group 1 second half array IDs assigned sample group 2.","code":""},{"path":"/reference/confounding.design.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Confounding Design — confounding.design","text":"","code":"# Completely confounding with reversed assignment cc.rev.ind <- confounding.design(seed = 1, num.array = 128,                              degree = \"complete\", rev.order = FALSE)  # Partially confounding pc.ind <- confounding.design(seed = 1, num.array = 128,                              degree = \"partial\")"},{"path":"/reference/create.storage.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Storage for Output — create.storage","title":"Create Storage for Output — create.storage","text":"implement precision.simulate function, according length design.list, class.list, norm.list, create storage list store output precision.simulate.","code":""},{"path":"/reference/create.storage.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Storage for Output — create.storage","text":"","code":"create.storage(   design.list = c(\"CC+\", \"CC-\", \"PC+\", \"PC-\"),   class.list = c(\"PAM\", \"LASSO\"),   norm.list = c(\"NN\", \"QN\"),   validating.sets = c(\"test\", \"gold.standard\") )"},{"path":"/reference/create.storage.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Storage for Output — create.storage","text":"design.list List design methods applied precision.simulate. class.list List classification methods applied precision.simulate norm.list List normalization methods applied precision.simulate validating.sets Types validation methods.","code":""},{"path":"/reference/create.storage.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Storage for Output — create.storage","text":"list whose size determined input parameters.","code":""},{"path":"/reference/create.storage.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create Storage for Output — create.storage","text":"create.storage","code":""},{"path":"/reference/create.storage.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Storage for Output — create.storage","text":"","code":"create.storage(design.list = c(\"CC+\", \"CC-\", \"PC+\", \"PC-\"),                class.list = c(\"PAM\", \"LASSO\"),                norm.list = c(\"NN\", \"QN\"),                validating.sets = c(\"test\", \"gold.standard\")) #>               CC+    CC-    PC+    PC-    #> test          list,4 list,4 list,4 list,4 #> gold.standard list,4 list,4 list,4 list,4"},{"path":"/reference/dlda.intcv.html","id":null,"dir":"Reference","previous_headings":"","what":"Diagonal Linear Discriminant Classifier — dlda.intcv","title":"Diagonal Linear Discriminant Classifier — dlda.intcv","text":"Build Diagonal Linear Discriminant classifier.","code":""},{"path":"/reference/dlda.intcv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Diagonal Linear Discriminant Classifier — dlda.intcv","text":"","code":"dlda.intcv(kfold = NULL, X, y, seed)"},{"path":"/reference/dlda.intcv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Diagonal Linear Discriminant Classifier — dlda.intcv","text":"kfold placeholder meaning, default NULL. X dataset trained. dataset must rows probes columns samples. y vector sample group sample dataset trained. must equal length number samples X. seed integer used initialize pseudorandom number generator.","code":""},{"path":"/reference/dlda.intcv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Diagonal Linear Discriminant Classifier — dlda.intcv","text":"list 4 elements: mc internal misclassification error rate time processing time model DLDA classifier","code":""},{"path":"/reference/dlda.intcv.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Diagonal Linear Discriminant Classifier — dlda.intcv","text":"https://cran.r-project.org/web/packages/HiDimDA/index.html","code":""},{"path":"/reference/dlda.intcv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Diagonal Linear Discriminant Classifier — dlda.intcv","text":"","code":"set.seed(101) biological.effect <- estimate.biological.effect(uhdata = uhdata.pl) ctrl.genes <- unique(rownames(uhdata.pl))[grep(\"NC\", unique(rownames(uhdata.pl)))] biological.effect.nc <- biological.effect[!rownames(biological.effect)   %in% ctrl.genes, ] group.id <- substr(colnames(biological.effect.nc), 7, 7)  biological.effect.train.ind <- colnames(biological.effect.nc)[c(sample(which(   group.id == \"E\"), size = 64),   sample(which(group.id == \"V\"), size = 64))] biological.effect.nc.tr <- biological.effect.nc[, biological.effect.train.ind]  dlda.int <- dlda.intcv(X = biological.effect.nc.tr,                      y = substr(colnames(biological.effect.nc.tr), 7, 7),                      kfold = NULL, seed = 1)"},{"path":"/reference/dlda.predict.html","id":null,"dir":"Reference","previous_headings":"","what":"Prediction with Diagonal Linear Discriminant classifier — dlda.predict","title":"Prediction with Diagonal Linear Discriminant classifier — dlda.predict","text":"Predict Diagonal Linear Discriminant classifier fit.","code":""},{"path":"/reference/dlda.predict.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prediction with Diagonal Linear Discriminant classifier — dlda.predict","text":"","code":"dlda.predict(dlda.intcv.model, pred.obj, pred.obj.group.id)"},{"path":"/reference/dlda.predict.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prediction with Diagonal Linear Discriminant classifier — dlda.predict","text":"dlda.intcv.model DLDA classifier built dlda.intcv. pred.obj dataset sample group predicted. dataset must rows probes columns samples. must equal number probes dataset trained. pred.obj.group.id vector sample-group labels sample dataset predicted. must equal length number samples pred.obj.","code":""},{"path":"/reference/dlda.predict.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prediction with Diagonal Linear Discriminant classifier — dlda.predict","text":"list 3 elements: pred predicted sample group sample mc predicted misclassification error rate (external validation) prob predicted probability sample","code":""},{"path":"/reference/dlda.predict.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Prediction with Diagonal Linear Discriminant classifier — dlda.predict","text":"https://cran.r-project.org/web/packages/HiDimDA/index.html","code":""},{"path":"/reference/dlda.predict.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prediction with Diagonal Linear Discriminant classifier — dlda.predict","text":"","code":"set.seed(101) biological.effect <- estimate.biological.effect(uhdata = uhdata.pl) ctrl.genes <- unique(rownames(uhdata.pl))[grep(\"NC\", unique(rownames(uhdata.pl)))] biological.effect.nc <- biological.effect[!rownames(biological.effect) %in% ctrl.genes, ] group.id <- substr(colnames(biological.effect.nc), 7, 7)  biological.effect.train.ind <- colnames(biological.effect.nc)[c(sample(which(group.id == \"E\"), size = 64),                                           sample(which(group.id == \"V\"), size = 64))] biological.effect.test.ind <- colnames(biological.effect.nc)[!colnames(biological.effect.nc) %in% biological.effect.train.ind]  biological.effect.nc.tr <- biological.effect.nc[, biological.effect.train.ind] biological.effect.nc.te <- biological.effect.nc[, biological.effect.test.ind]  dlda.int <- dlda.intcv(X = biological.effect.nc.tr,                      y = substr(colnames(biological.effect.nc.tr), 7, 7),                      kfold = 5, seed = 1)  dlda.pred <- dlda.predict(dlda.intcv.model = dlda.int,                         pred.obj = biological.effect.nc.te,                         pred.obj.group.id = substr(colnames(biological.effect.nc.te), 7, 7)) dlda.int$mc #> [1] 0.1171875 dlda.pred$mc #> [1] 0.140625"},{"path":"/reference/estimate.biological.effect.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimated Sample Effects — estimate.biological.effect","title":"Estimated Sample Effects — estimate.biological.effect","text":"Estimate biological effects sample uniformly-handled dataset.","code":""},{"path":"/reference/estimate.biological.effect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimated Sample Effects — estimate.biological.effect","text":"","code":"estimate.biological.effect(uhdata)"},{"path":"/reference/estimate.biological.effect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimated Sample Effects — estimate.biological.effect","text":"uhdata uniformly-handled dataset. dataset must rows probes columns samples.","code":""},{"path":"/reference/estimate.biological.effect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimated Sample Effects — estimate.biological.effect","text":"estimation sample effects","code":""},{"path":"/reference/estimate.biological.effect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimated Sample Effects — estimate.biological.effect","text":"","code":"biological.effect <- estimate.biological.effect(uhdata = uhdata.pl)"},{"path":"/reference/estimate.handling.effect.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimated handling effects — estimate.handling.effect","title":"Estimated handling effects — estimate.handling.effect","text":"Estimate handling effects array nonuniformly-handled dataset taking difference data data matched array uniformly-handled dataset.","code":""},{"path":"/reference/estimate.handling.effect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimated handling effects — estimate.handling.effect","text":"","code":"estimate.handling.effect(uhdata, nuhdata)"},{"path":"/reference/estimate.handling.effect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimated handling effects — estimate.handling.effect","text":"uhdata uniformly-handled dataset. dataset must rows probes columns samples. nuhdata nonuniformly-handled dataset. dataset must rows probes columns samples dimensions probe names uniformly-handled dataset.","code":""},{"path":"/reference/estimate.handling.effect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimated handling effects — estimate.handling.effect","text":"estimation handling effects","code":""},{"path":"/reference/estimate.handling.effect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimated handling effects — estimate.handling.effect","text":"","code":"handling.effect <- estimate.handling.effect(uhdata = uhdata.pl, nuhdata = nuhdata.pl)"},{"path":"/reference/extract.precision.error.html","id":null,"dir":"Reference","previous_headings":"","what":"Extracting errors from PRECISION (both non-FLEX and FLEX) output — extract.precision.error","title":"Extracting errors from PRECISION (both non-FLEX and FLEX) output — extract.precision.error","text":"Extract errors error_store list PRECISION output produced either precision.simulate.flex; reduce PRECISION output plotting.","code":""},{"path":"/reference/extract.precision.error.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extracting errors from PRECISION (both non-FLEX and FLEX) output — extract.precision.error","text":"","code":"extract.precision.error(precision.obj.path = NULL, precision.obj.name)"},{"path":"/reference/extract.precision.error.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extracting errors from PRECISION (both non-FLEX and FLEX) output — extract.precision.error","text":"precision.obj.path path document name PRECISION object. default, precision.obj.path = NULL indicates PRECISION object already existed current global environment. precision.obj.name string name PRECISION R object.","code":""},{"path":"/reference/extract.precision.error.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extracting errors from PRECISION (both non-FLEX and FLEX) output — extract.precision.error","text":"list lists containing errors PRECISION object names object","code":""},{"path":"/reference/extract.precision.error.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extracting errors from PRECISION (both non-FLEX and FLEX) output — extract.precision.error","text":"","code":"if (FALSE) { ## Load + extract errors from a PRECISION object precision.error.df <- extract.precision.error(precision.obj.path =   \"mypath/precision.result.Rdata\",   precision.obj.name = \"precision.result\")    ## Load + extract errors from a PRECISION FLEX object precision.flex.error.df <- extract.precision.error(precision.obj.path =   \"mypath/precision.flex.result.Rdata\",   precision.obj.name = \"precision.flex.result\")  ## Extract errors from a PRECISION FLEX object previously existed in global env load(\"mypath/precision.a.Rdata\") # load object named \"precision.a\" in global env precision.flex.error.df <- extract.precision.error(precision.obj.name = \"precision.flex.result\") }"},{"path":"/reference/knn.intcv.html","id":null,"dir":"Reference","previous_headings":"","what":"K-Nearest Neighbors Classifier — knn.intcv","title":"K-Nearest Neighbors Classifier — knn.intcv","text":"Build K-Nearest Neighbors classifier using internal cross validation choose turning parameter, 5-fold cross validation default.","code":""},{"path":"/reference/knn.intcv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"K-Nearest Neighbors Classifier — knn.intcv","text":"","code":"knn.intcv(kfold = 5, X, y, seed)"},{"path":"/reference/knn.intcv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"K-Nearest Neighbors Classifier — knn.intcv","text":"kfold number folds. default, kfold = 5. X dataset trained. dataset must rows probes columns samples. y vector sample group sample dataset trained. must equal length number samples X. seed integer used initialize pseudorandom number generator.","code":""},{"path":"/reference/knn.intcv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"K-Nearest Neighbors Classifier — knn.intcv","text":"list 4 elements: mc internal misclassification error rate time processing time performing internal validation kNN model kNN classifier","code":""},{"path":"/reference/knn.intcv.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"K-Nearest Neighbors Classifier — knn.intcv","text":"https://topepo.github.io/caret/","code":""},{"path":"/reference/knn.intcv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"K-Nearest Neighbors Classifier — knn.intcv","text":"","code":"set.seed(101) biological.effect <- estimate.biological.effect(uhdata = uhdata.pl) ctrl.genes <- unique(rownames(uhdata.pl))[grep(\"NC\", unique(rownames(uhdata.pl)))] biological.effect.nc <- biological.effect[!rownames(biological.effect)   %in% ctrl.genes, ] group.id <- substr(colnames(biological.effect.nc), 7, 7)  biological.effect.train.ind <- colnames(biological.effect.nc)[c(sample(which(   group.id == \"E\"), size = 64),   sample(which(group.id == \"V\"), size = 64))] biological.effect.nc.tr <- biological.effect.nc[, biological.effect.train.ind]  knn.int <- knn.intcv(X = biological.effect.nc.tr,                      y = substr(colnames(biological.effect.nc.tr), 7, 7),                      kfold = 5, seed = 1) #> Loading required package: ggplot2 #> Warning: package 'ggplot2' was built under R version 4.1.3 #> Loading required package: lattice"},{"path":"/reference/knn.predict.html","id":null,"dir":"Reference","previous_headings":"","what":"Prediction with K-Nearest Neighbors classifier — knn.predict","title":"Prediction with K-Nearest Neighbors classifier — knn.predict","text":"Predict K-Nearest Neighbors classifier fit.","code":""},{"path":"/reference/knn.predict.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prediction with K-Nearest Neighbors classifier — knn.predict","text":"","code":"knn.predict(knn.intcv.model, pred.obj, pred.obj.group.id)"},{"path":"/reference/knn.predict.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prediction with K-Nearest Neighbors classifier — knn.predict","text":"knn.intcv.model K-Nearest Neighbors classifier built knn.intcv. pred.obj dataset sample group predicted. dataset must rows probes columns samples. must equal number probes dataset trained. pred.obj.group.id vector sample-group labels sample dataset predicted. must equal length number samples pred.obj.","code":""},{"path":"/reference/knn.predict.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prediction with K-Nearest Neighbors classifier — knn.predict","text":"list 3 elements: pred predicted sample group sample mc predicted misclassification error rate (external validation) prob predicted probability sample","code":""},{"path":"/reference/knn.predict.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Prediction with K-Nearest Neighbors classifier — knn.predict","text":"https://topepo.github.io/caret/","code":""},{"path":"/reference/knn.predict.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prediction with K-Nearest Neighbors classifier — knn.predict","text":"","code":"set.seed(101) biological.effect <- estimate.biological.effect(uhdata = uhdata.pl) ctrl.genes <- unique(rownames(uhdata.pl))[grep(\"NC\", unique(rownames(uhdata.pl)))] biological.effect.nc <- biological.effect[!rownames(biological.effect) %in% ctrl.genes, ] group.id <- substr(colnames(biological.effect.nc), 7, 7)  biological.effect.train.ind <- colnames(biological.effect.nc)[c(sample(which(group.id == \"E\"), size = 64),                                           sample(which(group.id == \"V\"), size = 64))] biological.effect.test.ind <- colnames(biological.effect.nc)[!colnames(biological.effect.nc) %in% biological.effect.train.ind]  biological.effect.nc.tr <- biological.effect.nc[, biological.effect.train.ind] biological.effect.nc.te <- biological.effect.nc[, biological.effect.test.ind]  knn.int <- knn.intcv(X = biological.effect.nc.tr,                      y = substr(colnames(biological.effect.nc.tr), 7, 7),                      kfold = 5, seed = 1)  knn.pred <- knn.predict(knn.intcv.model = knn.int,                         pred.obj = biological.effect.nc.te,                         pred.obj.group.id = substr(colnames(biological.effect.nc.te), 7, 7)) knn.int$mc #> [1] 0.1798974 knn.pred$mc #> [1] 0.15625"},{"path":"/reference/lasso.intcv.html","id":null,"dir":"Reference","previous_headings":"","what":"Least absolute shrinkage and selection operator through internal cross validation — lasso.intcv","title":"Least absolute shrinkage and selection operator through internal cross validation — lasso.intcv","text":"Build LASSO classifier using internal cross validation choose turning parameter, 5-fold cross validation default.","code":""},{"path":"/reference/lasso.intcv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Least absolute shrinkage and selection operator through internal cross validation — lasso.intcv","text":"","code":"lasso.intcv(kfold = 5, X, y, seed, alp = 1)"},{"path":"/reference/lasso.intcv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Least absolute shrinkage and selection operator through internal cross validation — lasso.intcv","text":"kfold number folds. default, kfold = 5. X dataset trained. dataset must rows probes columns samples. y vector sample group sample dataset trained. must equal length number samples X. seed integer used initialize pseudorandom number generator. alp alpha, penalty type. can numeric value 0 1. default, alp = 1 LASSO. alp = 0 ridge value elastic net.","code":""},{"path":"/reference/lasso.intcv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Least absolute shrinkage and selection operator through internal cross validation — lasso.intcv","text":"list 4 elements: mc internal misclassification error rate time processing time performing internal validation LASSO model LASSO classifier, resulted cv.fit cfs estimated coefficients final classifier","code":""},{"path":"/reference/lasso.intcv.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Least absolute shrinkage and selection operator through internal cross validation — lasso.intcv","text":"Friedman, J., Hastie, T. Tibshirani, R. (2008) Regularization Paths Generalized Linear Mod- els via Coordinate Descent, http://www.stanford.edu/~hastie/Papers/glmnet.pdf Journal Statistical Software, Vol. 33(1), 1-22 Feb 2010","code":""},{"path":"/reference/lasso.intcv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Least absolute shrinkage and selection operator through internal cross validation — lasso.intcv","text":"","code":"set.seed(101) biological.effect <- estimate.biological.effect(uhdata = uhdata.pl) ctrl.genes <- unique(rownames(uhdata.pl))[grep(\"NC\", unique(rownames(uhdata.pl)))] biological.effect.nc <- biological.effect[!rownames(biological.effect)   %in% ctrl.genes, ] group.id <- substr(colnames(biological.effect.nc), 7, 7)  biological.effect.train.ind <- colnames(biological.effect.nc)[c(sample(which(   group.id == \"E\"), size = 64),   sample(which(group.id == \"V\"), size = 64))] biological.effect.nc.tr <- biological.effect.nc[, biological.effect.train.ind]  lasso.int <- lasso.intcv(X = biological.effect.nc.tr,                          y = substr(colnames(biological.effect.nc.tr), 7, 7),                          kfold = 5, seed = 1, alp = 1) #>"},{"path":"/reference/lasso.predict.html","id":null,"dir":"Reference","previous_headings":"","what":"Prediction with least absolute shrinkage and selection operator classifier — lasso.predict","title":"Prediction with least absolute shrinkage and selection operator classifier — lasso.predict","text":"Predict least absolute shrinkage selection operator fit.","code":""},{"path":"/reference/lasso.predict.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prediction with least absolute shrinkage and selection operator classifier — lasso.predict","text":"","code":"lasso.predict(lasso.intcv.model, pred.obj, pred.obj.group.id)"},{"path":"/reference/lasso.predict.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prediction with least absolute shrinkage and selection operator classifier — lasso.predict","text":"lasso.intcv.model LASSO classifier built lasso.intcv. pred.obj dataset sample group predicted. dataset must rows probes columns samples. must equal number probes dataset trained. pred.obj.group.id vector sample-group labels sample dataset predicted. must equal length number samples pred.obj.","code":""},{"path":"/reference/lasso.predict.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prediction with least absolute shrinkage and selection operator classifier — lasso.predict","text":"list 3 elements: pred predicted sample group sample mc predicted misclassification error rate (external validation) prob predicted probability sample","code":""},{"path":"/reference/lasso.predict.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Prediction with least absolute shrinkage and selection operator classifier — lasso.predict","text":"Friedman, J., Hastie, T. Tibshirani, R. (2008) Regularization Paths Generalized Linear Mod- els via Coordinate Descent, http://www.stanford.edu/~hastie/Papers/glmnet.pdf Journal Statistical Software, Vol. 33(1), 1-22 Feb 2010","code":""},{"path":"/reference/lasso.predict.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prediction with least absolute shrinkage and selection operator classifier — lasso.predict","text":"","code":"set.seed(101) biological.effect <- estimate.biological.effect(uhdata = uhdata.pl) ctrl.genes <- unique(rownames(uhdata.pl))[grep(\"NC\", unique(rownames(uhdata.pl)))] biological.effect.nc <- biological.effect[!rownames(biological.effect) %in% ctrl.genes, ] group.id <- substr(colnames(biological.effect.nc), 7, 7)  biological.effect.train.ind <- colnames(biological.effect.nc)[c(sample(which(group.id == \"E\"), size = 64),                                           sample(which(group.id == \"V\"), size = 64))] biological.effect.test.ind <- colnames(biological.effect.nc)[!colnames(biological.effect.nc) %in% biological.effect.train.ind]  biological.effect.nc.tr <- biological.effect.nc[, biological.effect.train.ind] biological.effect.nc.te <- biological.effect.nc[, biological.effect.test.ind]  lasso.int <- lasso.intcv(X = biological.effect.nc.tr,                          y = substr(colnames(biological.effect.nc.tr), 7, 7),                          kfold = 5, seed = 1, alp = 1) #>   lasso.pred <- lasso.predict(lasso.intcv.model = lasso.int,                             pred.obj = biological.effect.nc.te,                             pred.obj.group.id = substr(colnames(biological.effect.nc.te), 7, 7)) lasso.int$mc #> [1] 0.1484375 lasso.pred$mc #> [1] 0.15625"},{"path":"/reference/limma.pbset.html","id":null,"dir":"Reference","previous_headings":"","what":"Differential expression analysis of probe-set data — limma.pbset","title":"Differential expression analysis of probe-set data — limma.pbset","text":"Perform two-group differential expression analysis using \"limma\".","code":""},{"path":"/reference/limma.pbset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Differential expression analysis of probe-set data — limma.pbset","text":"","code":"limma.pbset(data, group.id, group.id.level = c(\"E\", \"V\"), pbset.id = NULL)"},{"path":"/reference/limma.pbset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Differential expression analysis of probe-set data — limma.pbset","text":"data dataset analyzed. dataset must rows unique probe-sets columns samples. group.id vector sample-group labels sample dataset. must 2-level non-numeric factor vector. group.id.level vector sample-group label level. must two two elements first element reference. default, group.id.level = c(\"E\", \"V\"). study, compare endometrial tumor samples ovarian tumor samples, endometrial reference. pbset.id vector unique probe-set names. default, pbset.id = NULL row names dataset.","code":""},{"path":"/reference/limma.pbset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Differential expression analysis of probe-set data — limma.pbset","text":"data frame differential expression analysis results, group means group standard deviations, unique probe-set.","code":""},{"path":"/reference/limma.pbset.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Differential expression analysis of probe-set data — limma.pbset","text":"Ritchie M., Phipson B., Wu D., Hu Y., Law C., Shi W. Smyth G. (2015). \"limma powers differential expression analyses RNA-sequencing microarray studies.\" Nucleic Acids Research, 43(7), pp. e47.","code":""},{"path":"/reference/limma.pbset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Differential expression analysis of probe-set data — limma.pbset","text":"","code":"uhdata.psl <- med.sum.pbset(data = uhdata.pl,                             num.per.unipbset = 10) ctrl.genes <- unique(rownames(uhdata.pl))[grep(\"NC\", unique(rownames(uhdata.pl)))]  uhdata.psl.nc <- uhdata.psl[!rownames(uhdata.psl) %in% ctrl.genes, ]  group.id <- substr(colnames(uhdata.psl.nc), 7, 7) group.id.level <- levels(as.factor(group.id))  limma.fit.uhdata<- limma.pbset(data = uhdata.psl.nc,                                group.id = group.id,                                group.id.level = group.id.level)                                table(limma.fit.uhdata$P.Value < 0.01,                                dnn = \"DE genes\") #> DE genes #> FALSE  TRUE  #>   159    16"},{"path":"/reference/med.norm.html","id":null,"dir":"Reference","previous_headings":"","what":"Median normalization — med.norm","title":"Median normalization — med.norm","text":"Normalize training dataset array shares median store median training dataset reference frozen median normalize test dataset. Also two options available: normalize training dataset frozen normalize test dataset, vise versa.","code":""},{"path":"/reference/med.norm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Median normalization — med.norm","text":"","code":"med.norm(train = NULL, test = NULL, ref.dis = NULL)"},{"path":"/reference/med.norm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Median normalization — med.norm","text":"train training dataset median normalized. dataset must rows probes columns samples. can left unspecified ref.dis suppied frozen normalize test set. test test dataset frozen median normalized. dataset must rows probes columns samples. number rows must equal number rows training set. default, test set specified (test = NULL) frozen normalization performed. ref.dis reference distribution frozen median normalize test set previously normalized training set. required train supplied. default, ref.dis = NULL.","code":""},{"path":"/reference/med.norm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Median normalization — med.norm","text":"list two datasets one reference distribution: train.mn normalized training set, training set specified test.fmn frozen normalized test set, test set specified ref.dis reference distribution","code":""},{"path":"/reference/med.norm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Median normalization — med.norm","text":"","code":"set.seed(101) group.id <- substr(colnames(nuhdata.pl), 7, 7) train.ind <- colnames(nuhdata.pl)[c(sample(which(group.id == \"E\"), size = 64),                                sample(which(group.id == \"V\"), size = 64))] train.dat <- nuhdata.pl[, train.ind] test.dat <- nuhdata.pl[, !colnames(nuhdata.pl) %in% train.ind]  # normalize only training set data.mn <- med.norm(train = train.dat) str(data.mn) #> List of 3 #>  $ train.mn: num [1:1810, 1:128] 8.5 8.39 8.14 8.47 8.45 ... #>   ..- attr(*, \"dimnames\")=List of 2 #>   .. ..$ : chr [1:1810] \"A_25_P00011991\" \"A_25_P00011991\" \"A_25_P00011991\" \"A_25_P00011991\" ... #>   .. ..$ : chr [1:128] \"GL5140E\" \"JB5556E\" \"JB4783E\" \"GL4527E\" ... #>  $ test.fmn: NULL #>  $ ref.dis : num 5.43  # normalize training set and frozen normalize test set data.mn <- med.norm(train = train.dat, test = test.dat) str(data.mn) #> List of 3 #>  $ train.mn: num [1:1810, 1:128] 8.5 8.39 8.14 8.47 8.45 ... #>   ..- attr(*, \"dimnames\")=List of 2 #>   .. ..$ : chr [1:1810] \"A_25_P00011991\" \"A_25_P00011991\" \"A_25_P00011991\" \"A_25_P00011991\" ... #>   .. ..$ : chr [1:128] \"GL5140E\" \"JB5556E\" \"JB4783E\" \"GL4527E\" ... #>  $ test.fmn: num [1:1810, 1:64] 6.48 6.92 7.21 5.92 6.14 ... #>   ..- attr(*, \"dimnames\")=List of 2 #>   .. ..$ : chr [1:1810] \"A_25_P00011991\" \"A_25_P00011991\" \"A_25_P00011991\" \"A_25_P00011991\" ... #>   .. ..$ : chr [1:64] \"JB4166E\" \"JB5669E\" \"JB4112E\" \"JB5847E\" ... #>  $ ref.dis : num 5.43  # frozen normalize test set with reference distribution ref <- med.norm(train = train.dat)$ref.dis data.mn <- med.norm(test = test.dat, ref.dis = ref) str(data.mn) #> List of 3 #>  $ train.mn: NULL #>  $ test.fmn: num [1:1810, 1:64] 6.48 6.92 7.21 5.92 6.14 ... #>   ..- attr(*, \"dimnames\")=List of 2 #>   .. ..$ : chr [1:1810] \"A_25_P00011991\" \"A_25_P00011991\" \"A_25_P00011991\" \"A_25_P00011991\" ... #>   .. ..$ : chr [1:64] \"JB4166E\" \"JB5669E\" \"JB4112E\" \"JB5847E\" ... #>  $ ref.dis : num 5.43"},{"path":"/reference/med.sum.pbset.html","id":null,"dir":"Reference","previous_headings":"","what":"Probe-set median summarization — med.sum.pbset","title":"Probe-set median summarization — med.sum.pbset","text":"Summarize probe-set using median unique probe takes data matrix number probes per unique probe-set.","code":""},{"path":"/reference/med.sum.pbset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Probe-set median summarization — med.sum.pbset","text":"","code":"med.sum.pbset(data, pbset.id = NULL, num.per.unipbset = 10)"},{"path":"/reference/med.sum.pbset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Probe-set median summarization — med.sum.pbset","text":"data dataset summarized. dataset must rows probes columns samples. must data matrix number probes per unique probe-set. already probe-set level, manipulation done. pbset.id vector unique probe-set names. specified, default set unique probe names data. num.per.unipbset number probes unique probe-set. default, num.per.unipbset = 10.","code":""},{"path":"/reference/med.sum.pbset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Probe-set median summarization — med.sum.pbset","text":"probe-set median summarized data","code":""},{"path":"/reference/med.sum.pbset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Probe-set median summarization — med.sum.pbset","text":"","code":"if (FALSE) { uhdata.psl <- med.sum.pbset(data = uhdata.pl,                             num.per.unipbset = 10) }"},{"path":"/reference/nuhdata.pl.html","id":null,"dir":"Reference","previous_headings":"","what":"The nonuniformly-handled probe-level dataset,\r\n10 probes for each unique probe — nuhdata.pl","title":"The nonuniformly-handled probe-level dataset,\r\n10 probes for each unique probe — nuhdata.pl","text":"five percent random subset nonuniformly-handled probe-level dataset, 10 probes per unique probe. expressions log2 scale without background adjustmnet. dataset consists 181 unique probes, 6 negatively biological control probes Agilent array platform: \"NC2_00079215\", \"NC1_00000215\", \"NC1_00000197\", \"NC2_00122731\", \"NC2_00092197\", \"NC2_00106057\". sample IDs (column names) ending \"E\" \"V\" used indicate whether sample endometrial ovarian tumor sample. 96 endometrial 96 ovarian tumor samples.","code":""},{"path":"/reference/nuhdata.pl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The nonuniformly-handled probe-level dataset,\r\n10 probes for each unique probe — nuhdata.pl","text":"","code":"nuhdata.pl"},{"path":"/reference/nuhdata.pl.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"The nonuniformly-handled probe-level dataset,\r\n10 probes for each unique probe — nuhdata.pl","text":"data matrix 1810 rows (probes) 192 columns (samples).","code":""},{"path":"/reference/pam.intcv.html","id":null,"dir":"Reference","previous_headings":"","what":"Nearest shrunken centroid through internal cross validation — pam.intcv","title":"Nearest shrunken centroid through internal cross validation — pam.intcv","text":"Build PAM classifier using internal cross validation choose tuning parameter, 5-fold cross validation default.","code":""},{"path":"/reference/pam.intcv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nearest shrunken centroid through internal cross validation — pam.intcv","text":"","code":"pam.intcv(X, y, vt.k = NULL, n.k = 30, kfold = 5, folds = NULL, seed)"},{"path":"/reference/pam.intcv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nearest shrunken centroid through internal cross validation — pam.intcv","text":"X dataset trained. dataset must rows probes columns samples. y vector sample group sample dataset trained. must equal length number samples X. vt.k custom-specified threshold list. default, vt.k = NULL 30 values predetermined pamr package. n.k number threshold values desired. default, n.k = 30. kfold number folds. default, kfold = 5. folds pre-specifies samples fold. default, folds = NULL pre-specification. seed integer used initialize pseudorandom number generator.","code":""},{"path":"/reference/pam.intcv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nearest shrunken centroid through internal cross validation — pam.intcv","text":"list 4 elements: mc internal misclassification error rate time processing time performing internal validation PAM model PAM classifier, resulted pamr.train cfs estimated coefficients final classifier","code":""},{"path":"/reference/pam.intcv.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Nearest shrunken centroid through internal cross validation — pam.intcv","text":"T. Hastie, R. Tibshirani, Balasubramanian Narasimhan Gil Chu (2014). pamr: Pam: prediction analysis microarrays. R package version 1.55. https://CRAN.R-project.org/package=pamr","code":""},{"path":"/reference/pam.intcv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nearest shrunken centroid through internal cross validation — pam.intcv","text":"","code":"set.seed(101) biological.effect <- estimate.biological.effect(uhdata = uhdata.pl) ctrl.genes <- unique(rownames(uhdata.pl))[grep(\"NC\", unique(rownames(uhdata.pl)))] biological.effect.nc <- biological.effect[!rownames(biological.effect) %in% ctrl.genes, ] group.id <- substr(colnames(biological.effect.nc), 7, 7)  biological.effect.train.ind <- colnames(biological.effect.nc)[c(sample(which(group.id == \"E\"), size = 64),                                          sample(which(group.id == \"V\"), size = 64))] biological.effect.nc.tr <- biological.effect.nc[, biological.effect.train.ind]  pam.int <- pam.intcv(X = biological.effect.nc.tr,                      y = substr(colnames(biological.effect.nc.tr), 7, 7),                      kfold = 5, seed = 1) #> 12345678910111213141516171819202122232425262728293012Fold 1 :123456789101112131415161718192021222324252627282930 #> Fold 2 :123456789101112131415161718192021222324252627282930 #> Fold 3 :123456789101112131415161718192021222324252627282930 #> Fold 4 :123456789101112131415161718192021222324252627282930 #> Fold 5 :123456789101112131415161718192021222324252627282930 #> 1      id             E-score V-score #>  [1,] A_25_P00010987 0.2963  -0.2963 #>  [2,] A_25_P00010987 0.2384  -0.2384 #>  [3,] A_25_P00012126 -0.2247 0.2247  #>  [4,] A_25_P00010987 0.2165  -0.2165 #>  [5,] A_25_P00010987 0.211   -0.211  #>  [6,] A_25_P00012126 -0.2081 0.2081  #>  [7,] A_25_P00012126 -0.2077 0.2077  #>  [8,] A_25_P00012126 -0.2061 0.2061  #>  [9,] A_25_P00010987 0.2018  -0.2018 #> [10,] A_25_P00012126 -0.1937 0.1937  #> [11,] A_25_P00012126 -0.1929 0.1929  #> [12,] A_25_P00012126 -0.1875 0.1875  #> [13,] A_25_P00012126 -0.1859 0.1859  #> [14,] A_25_P00010987 0.181   -0.181  #> [15,] A_25_P00012126 -0.1739 0.1739  #> [16,] A_25_P00010987 0.1707  -0.1707 #> [17,] A_25_P00012126 -0.1664 0.1664  #> [18,] A_25_P00010987 0.1601  -0.1601 #> [19,] A_25_P00014849 -0.1545 0.1545  #> [20,] A_25_P00010987 0.1504  -0.1504 #> [21,] A_25_P00010987 0.1453  -0.1453 #> [22,] A_25_P00014849 -0.1383 0.1383  #> [23,] A_25_P00012150 0.126   -0.126  #> [24,] A_25_P00012150 0.1241  -0.1241 #> [25,] A_25_P00014849 -0.1206 0.1206  #> [26,] A_25_P00014849 -0.1124 0.1124  #> [27,] A_25_P00014849 -0.1105 0.1105  #> [28,] A_25_P00012150 0.1079  -0.1079 #> [29,] A_25_P00014849 -0.1054 0.1054  #> [30,] A_25_P00012150 0.1051  -0.1051 #> [31,] A_25_P00014849 -0.0998 0.0998  #> [32,] A_25_P00012150 0.0988  -0.0988 #> [33,] A_25_P00012150 0.0985  -0.0985 #> [34,] A_25_P00012150 0.0938  -0.0938 #> [35,] A_25_P00014849 -0.0867 0.0867  #> [36,] A_25_P00012150 0.0862  -0.0862 #> [37,] A_25_P00014849 -0.0828 0.0828  #> [38,] A_25_P00012150 0.0767  -0.0767 #> [39,] A_25_P00012150 0.058   -0.058  #> [40,] A_25_P00014849 -0.0575 0.0575  #> [41,] A_25_P00011017 -0.0541 0.0541  #> [42,] A_25_P00011017 -0.0365 0.0365  #> [43,] A_25_P00011017 -0.0361 0.0361  #> [44,] A_25_P00010683 -0.0317 0.0317  #> [45,] A_25_P00012138 0.0263  -0.0263 #> [46,] A_25_P00012697 0.0166  -0.0166 #> [47,] A_25_P00012138 0.0115  -0.0115 #> [48,] A_25_P00010683 -0.0114 0.0114  #> [49,] A_25_P00012138 0.0094  -0.0094 #> [50,] A_25_P00010132 0.0079  -0.0079 #> [51,] A_25_P00015907 -0.0023 0.0023  #> [52,] A_25_P00011017 -0.0017 0.0017  #> [53,] A_25_P00012970 -0.0017 0.0017  #> [54,] A_25_P00010683 -3e-04  3e-04   #>"},{"path":"/reference/pam.predict.html","id":null,"dir":"Reference","previous_headings":"","what":"Prediction with nearest shrunken centroid classifier — pam.predict","title":"Prediction with nearest shrunken centroid classifier — pam.predict","text":"Predict nearest shrunken centroid fit.","code":""},{"path":"/reference/pam.predict.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prediction with nearest shrunken centroid classifier — pam.predict","text":"","code":"pam.predict(pam.intcv.model, pred.obj, pred.obj.group.id)"},{"path":"/reference/pam.predict.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prediction with nearest shrunken centroid classifier — pam.predict","text":"pam.intcv.model PAM classifier built pam.intcv. pred.obj dataset sample group predicted. dataset must rows probes columns samples. must equal number probes dataset trained. pred.obj.group.id vector sample-group labels sample dataset predicted. must equal length number samples pred.obj.","code":""},{"path":"/reference/pam.predict.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prediction with nearest shrunken centroid classifier — pam.predict","text":"list 3 elements: pred predicted sample group sample mc predicted misclassification error rate (external validation) prob predicted probability sample","code":""},{"path":"/reference/pam.predict.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Prediction with nearest shrunken centroid classifier — pam.predict","text":"T. Hastie, R. Tibshirani, Balasubramanian Narasimhan Gil Chu (2014). pamr: Pam: prediction analysis microarrays. R package version 1.55. https://CRAN.R-project.org/package=pamr","code":""},{"path":"/reference/pam.predict.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prediction with nearest shrunken centroid classifier — pam.predict","text":"","code":"set.seed(101) biological.effect <- estimate.biological.effect(uhdata = uhdata.pl) ctrl.genes <- unique(rownames(uhdata.pl))[grep(\"NC\", unique(rownames(uhdata.pl)))] biological.effect.nc <- biological.effect[!rownames(biological.effect) %in% ctrl.genes, ] group.id <- substr(colnames(biological.effect.nc), 7, 7)  biological.effect.train.ind <- colnames(biological.effect.nc)[c(sample(which(group.id == \"E\"), size = 64),                                           sample(which(group.id == \"V\"), size = 64))] biological.effect.test.ind <- colnames(biological.effect.nc)[!colnames(biological.effect.nc) %in% biological.effect.train.ind]  biological.effect.nc.tr <- biological.effect.nc[, biological.effect.train.ind] biological.effect.nc.te <- biological.effect.nc[, biological.effect.test.ind]  pam.int <- pam.intcv(X = biological.effect.nc.tr,                      y = substr(colnames(biological.effect.nc.tr), 7, 7),                      kfold = 5, seed = 1) #> 12345678910111213141516171819202122232425262728293012Fold 1 :123456789101112131415161718192021222324252627282930 #> Fold 2 :123456789101112131415161718192021222324252627282930 #> Fold 3 :123456789101112131415161718192021222324252627282930 #> Fold 4 :123456789101112131415161718192021222324252627282930 #> Fold 5 :123456789101112131415161718192021222324252627282930 #> 1      id             E-score V-score #>  [1,] A_25_P00010987 0.2963  -0.2963 #>  [2,] A_25_P00010987 0.2384  -0.2384 #>  [3,] A_25_P00012126 -0.2247 0.2247  #>  [4,] A_25_P00010987 0.2165  -0.2165 #>  [5,] A_25_P00010987 0.211   -0.211  #>  [6,] A_25_P00012126 -0.2081 0.2081  #>  [7,] A_25_P00012126 -0.2077 0.2077  #>  [8,] A_25_P00012126 -0.2061 0.2061  #>  [9,] A_25_P00010987 0.2018  -0.2018 #> [10,] A_25_P00012126 -0.1937 0.1937  #> [11,] A_25_P00012126 -0.1929 0.1929  #> [12,] A_25_P00012126 -0.1875 0.1875  #> [13,] A_25_P00012126 -0.1859 0.1859  #> [14,] A_25_P00010987 0.181   -0.181  #> [15,] A_25_P00012126 -0.1739 0.1739  #> [16,] A_25_P00010987 0.1707  -0.1707 #> [17,] A_25_P00012126 -0.1664 0.1664  #> [18,] A_25_P00010987 0.1601  -0.1601 #> [19,] A_25_P00014849 -0.1545 0.1545  #> [20,] A_25_P00010987 0.1504  -0.1504 #> [21,] A_25_P00010987 0.1453  -0.1453 #> [22,] A_25_P00014849 -0.1383 0.1383  #> [23,] A_25_P00012150 0.126   -0.126  #> [24,] A_25_P00012150 0.1241  -0.1241 #> [25,] A_25_P00014849 -0.1206 0.1206  #> [26,] A_25_P00014849 -0.1124 0.1124  #> [27,] A_25_P00014849 -0.1105 0.1105  #> [28,] A_25_P00012150 0.1079  -0.1079 #> [29,] A_25_P00014849 -0.1054 0.1054  #> [30,] A_25_P00012150 0.1051  -0.1051 #> [31,] A_25_P00014849 -0.0998 0.0998  #> [32,] A_25_P00012150 0.0988  -0.0988 #> [33,] A_25_P00012150 0.0985  -0.0985 #> [34,] A_25_P00012150 0.0938  -0.0938 #> [35,] A_25_P00014849 -0.0867 0.0867  #> [36,] A_25_P00012150 0.0862  -0.0862 #> [37,] A_25_P00014849 -0.0828 0.0828  #> [38,] A_25_P00012150 0.0767  -0.0767 #> [39,] A_25_P00012150 0.058   -0.058  #> [40,] A_25_P00014849 -0.0575 0.0575  #> [41,] A_25_P00011017 -0.0541 0.0541  #> [42,] A_25_P00011017 -0.0365 0.0365  #> [43,] A_25_P00011017 -0.0361 0.0361  #> [44,] A_25_P00010683 -0.0317 0.0317  #> [45,] A_25_P00012138 0.0263  -0.0263 #> [46,] A_25_P00012697 0.0166  -0.0166 #> [47,] A_25_P00012138 0.0115  -0.0115 #> [48,] A_25_P00010683 -0.0114 0.0114  #> [49,] A_25_P00012138 0.0094  -0.0094 #> [50,] A_25_P00010132 0.0079  -0.0079 #> [51,] A_25_P00015907 -0.0023 0.0023  #> [52,] A_25_P00011017 -0.0017 0.0017  #> [53,] A_25_P00012970 -0.0017 0.0017  #> [54,] A_25_P00010683 -3e-04  3e-04   #>   pam.pred <- pam.predict(pam.intcv.model = pam.int,                         pred.obj = biological.effect.nc.te,                         pred.obj.group.id = substr(colnames(biological.effect.nc.te), 7, 7)) pam.int$mc #> [1] 0.1171875 pam.pred$mc #> [1] 0.125"},{"path":"/reference/per.unipbset.truncate.html","id":null,"dir":"Reference","previous_headings":"","what":"Probe-level data truncation to a fixed number of probes per unique probe-set — per.unipbset.truncate","title":"Probe-level data truncation to a fixed number of probes per unique probe-set — per.unipbset.truncate","text":"Truncate probe-level dataset fixed number probes per unique probe-set. safe variation among replicates probe small.","code":""},{"path":"/reference/per.unipbset.truncate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Probe-level data truncation to a fixed number of probes per unique probe-set — per.unipbset.truncate","text":"","code":"per.unipbset.truncate(data, pbset.id = NULL, num.per.unipbset = 10)"},{"path":"/reference/per.unipbset.truncate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Probe-level data truncation to a fixed number of probes per unique probe-set — per.unipbset.truncate","text":"data probe-level dataset. dataset must rows probes columns samples. pbset.id vector unique probe-set names. default, pbset.id = NULL row names dataset. num.per.unipbset number probes unique probe-set truncated . default, num.per.unipbset = 10.","code":""},{"path":"/reference/per.unipbset.truncate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Probe-level data truncation to a fixed number of probes per unique probe-set — per.unipbset.truncate","text":"truncated probe-level data","code":""},{"path":"/reference/per.unipbset.truncate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Probe-level data truncation to a fixed number of probes per unique probe-set — per.unipbset.truncate","text":"","code":"uhdata.pl.p5 <- per.unipbset.truncate(data = uhdata.pl, num.per.unipbset = 5)"},{"path":"/reference/plot.precision.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot misclassification error rates from PRECISION (both non-FLEX and FLEX) output — plot.precision","title":"Plot misclassification error rates from PRECISION (both non-FLEX and FLEX) output — plot.precision","text":"Plot error rates PRECISION output extracted extract.precision.error","code":""},{"path":"/reference/plot.precision.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot misclassification error rates from PRECISION (both non-FLEX and FLEX) output — plot.precision","text":"","code":"# S3 method for precision plot(   data,   mytitle = \"PRECISION results (misclass. error rates)\",   design.order = NULL,   ylim = c(0, 0.5),   iflex = TRUE )"},{"path":"/reference/plot.precision.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot misclassification error rates from PRECISION (both non-FLEX and FLEX) output — plot.precision","text":"data resulted PRECISION output extract.precision.error. mytitle title plot. design.order indices order user like plot resulted output extract.precision.error. default, every simulation plotted. ylim y limit. default, ylim = c(0, 0.5). iflex whether data PRECISION output precision.simulate precision.simulate.flex. default, iflex = TRUE indicating data precision.simulate.flex.","code":""},{"path":"/reference/plot.precision.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot misclassification error rates from PRECISION (both non-FLEX and FLEX) output — plot.precision","text":"boxplot misclassification error rates","code":""},{"path":"/reference/plot.precision.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot misclassification error rates from PRECISION (both non-FLEX and FLEX) output — plot.precision","text":"","code":"if (FALSE) { ## PRECISION output plot.precision(data = precision.results.err.df,   design.order = 1:10,   mytitle = \"My PRECISION results\", iflex = FALSE)  ## PRECISION FLEX output plot.precision(data = precision.results.flex.err.df,   design.order = 1:10,   mytitle = \"My PRECISION FLEX results\")  # exclude ext.uh plot.precision(data = precision.results.flex.err.df[!names(precision.results.flex.err.df) %in% \"ext.uh\"],   design.order = 1:10,   mytitle = \"My PRECISION FLEX results\") }"},{"path":"/reference/plot.precision.multiclass.html","id":null,"dir":"Reference","previous_headings":"","what":"plot.precision.multiclass — plot.precision.multiclass","title":"plot.precision.multiclass — plot.precision.multiclass","text":"Plot average external error rate different classifications output precision.simulate.multiclass","code":""},{"path":"/reference/plot.precision.multiclass.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plot.precision.multiclass — plot.precision.multiclass","text":"","code":"# S3 method for precision.multiclass plot(   data,   mytitle = \"Average external error rates\",   class.order = NULL,   ylim = c(0, 0.5),   save.name = NULL )"},{"path":"/reference/plot.precision.multiclass.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plot.precision.multiclass — plot.precision.multiclass","text":"data output variable precision.simulate.multiclass mytitle plot title class.order order classifications ylim length y axis plot save.name plot name saved NULL","code":""},{"path":"/reference/plot.precision.multiclass.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"plot.precision.multiclass — plot.precision.multiclass","text":"","code":"if (FALSE) { set.seed(101) biological.effect <- estimate.biological.effect(uhdata = uhdata.pl) handling.effect <- estimate.handling.effect(uhdata = uhdata.pl,                              nuhdata = nuhdata.pl)  ctrl.genes <- unique(rownames(uhdata.pl))[grep(\"NC\", unique(rownames(uhdata.pl)))]  biological.effect.nc <- biological.effect[!rownames(biological.effect) %in% ctrl.genes, ] handling.effect.nc <- handling.effect[!rownames(handling.effect) %in% ctrl.genes, ]  group.id <- substr(colnames(biological.effect.nc), 7, 7)  # randomly split biological effect data into training and test set with # equal number of endometrial and ovarian samples biological.effect.train.ind <- colnames(biological.effect.nc)[c(sample(which(group.id == \"E\"), size = 64),                                           sample(which(group.id == \"V\"), size = 64))] biological.effect.test.ind <- colnames(biological.effect.nc)[!colnames(biological.effect.nc) %in% biological.effect.train.ind] biological.effect.train.test.split =   list(\"tr\" = biological.effect.train.ind,        \"te\" = biological.effect.test.ind)  # non-randomly split handling effect data into training and test set handling.effect.train.test.split =   list(\"tr\" = c(1:64, 129:192),        \"te\" = 65:128)  biological.effect.nc.tr <- biological.effect.nc[, biological.effect.train.ind] biological.effect.nc.te <- biological.effect.nc[, biological.effect.test.ind] handling.effect.nc.tr <- handling.effect.nc[, c(1:64, 129:192)] handling.effect.nc.te <- handling.effect.nc[, 65:128]  # Simulation precision.multiclass.results = precision.simulate.multiclass(seed = 0, N = 3,                                             biological.effect.tr = biological.effect.nc.tr,                                             biological.effect.te = biological.effect.nc.te,                                             handling.effect.tr = handling.effect.nc.tr,                                             handling.effect.te = handling.effect.nc.te,                                             group.id.tr = substr(colnames(biological.effect.nc.tr), 7, 7),                                             group.id.te = substr(colnames(biological.effect.nc.te), 7, 7),                                             train.design.met = \"BLK\",                                             test.design.met = \"STR\",                                             train.norm.met = \"MN\",                                             test.norm.met = \"fMN\",                                             class.list = c(\"SVM\", \"kNN\", \"LASSO\"),                                             train.batch.id = list(1:40, 41:64, (129:152)-64, (153:192)-64),                                             test.batch.id = list((65:80)-64,(81:114)-64,(115:128)-64))  # Plot plot.precision.multiclass(data = precision.multiclass.results,                           mytitle = \"Average external error rates\",                           class.order = c(\"SVM\", \"kNN\", \"ClaNC\"),                           ylim = c(0,0.5),                           save.name = \"myimage\") }"},{"path":"/reference/precision.simulate.class.html","id":null,"dir":"Reference","previous_headings":"","what":"precision simulation with classification — precision.simulate.class","title":"precision simulation with classification — precision.simulate.class","text":"Classification analysis applied different normalization study design. Perform simulation study Qin et al. (see reference).","code":""},{"path":"/reference/precision.simulate.class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"precision simulation with classification — precision.simulate.class","text":"","code":"# S3 method for simulate.class precision(   seed,   N,   biological.effect.tr,   biological.effect.te,   handling.effect.tr,   handling.effect.te,   group.id.tr,   group.id.te,   train.design.met = \"NONE\",   test.design.met = \"NONE\",   train.norm.met = \"NN\",   test.norm.met = \"NN\",   class.met = \"LASSO\",   train.batch.id = NULL,   test.batch.id = NULL,   icombat = FALSE,   isva = FALSE,   iruv = FALSE,   biological.effect.tr.ctrl = NULL,   handling.effect.tr.ctrl = NULL,   norm.funcs = NULL,   class.funcs = NULL,   pred.funcs = NULL )"},{"path":"/reference/precision.simulate.class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"precision simulation with classification — precision.simulate.class","text":"seed integer used initialize pseudorandom number generator. N number simulation runs. biological.effect.tr training set estimated biological effects. dataset must rows probes columns samples. biological.effect.te test set estimated biological effects. dataset must rows probes columns samples. must number probes probe names training set estimated biological effects. handling.effect.tr training set estimated handling effects. dataset must rows probes columns samples. must dimensions probe names training set estimated biological effects. handling.effect.te test set estimated handling effects. dataset must rows probes, columns samples. must dimensions probe names training set estimated handling effects. group.id.tr vector sample-group labels sample training set estimated biological effects. must 2-level non-numeric factor vector. group.id.te vector sample-group labels sample test set estimated biological effects. must 2-level non-numeric factor vector. train.design.met string study design applied training set. built-designs \"NONE\", CC+\", \"CC-\", \"PC+\", \"PC-\", \"BLK\", \"STR\" \"Rehybridization\", \"Complete Confounding 1\", \"Complete Confounding 2\", \"Partial Confounding 1\", \"Partial Confounding 2\", \"Blocking\", \"Stratification\" Qin et al. test.design.met string study design applied test set. built-designs \"NONE\", CC+\", \"CC-\", \"PC+\", \"PC-\", \"BLK\", \"STR\" \"Rehybridization\", \"Complete Confounding 1\", \"Complete Confounding 2\", \"Partial Confounding 1\", \"Partial Confounding 2\", \"Blocking\", \"Stratification\" Qin et al. train.norm.met string normalization method applied training set. build-available normalization methods \"NN\", \"QN\", \"MN\", \"VSN\" \"Normalization\", \"Quantile Normalization\", \"Median Normalization\", \"Variance Stabilizing Normalization\". User can provide list normalization methods given functions supplied (also see norm.funcs). test.norm.met string normalization method applied test set. build-available normalization methods \"NN\", \"MN\", \"QN\", \"fMN\", \"fQN\", \"pMN\", \"pQN\", \"fVSN\", \"Normalization\", \"Median Normalization\", \"Quantile Normalization\", \"Frozen Median Normalization\", \"Frozen Quantile Normalization\", \"Pool Median Normalization\", \"Pool Quantile Normalization\", \"Frozen Vairance Stability Normalization\". User can provide list normalization methods given functions supplied (also see norm.funcs). class.met string classfication method fitted training set predict test set. build-available classfication methods \"PAM\", \"LASSO\", \"ClaNC\", \"ranFor\", \"SVM\", \"kNN\" \"DLDA\", \"Prediction Analysis Microarrays\", \"Least Absolute Shrinkage Selection Operator\", \"Classification Nearest Centroids\", \"Random Forest\", \"Support Vector Machine\", \"K-Nearest Neighbors\" \"Diagonal Linear Discriminant\". User can provide list classification methods given correponding model-building predicting functions supplied (also see class.funcs pred.funcs). can also use classification method setting class.met \"custom\". format create custom.intcv custom.predict please refers classification methods package. icombat indicator combat adjustment. default, icombat = FALSE ComBat adjustment. isva indicator sva adjustment. default, isva = FALSE sva adjustment. iruv indicator RUV-4 adjustment. default, iruv = FALSE RUV-4 adjustment. biological.effect.tr.ctrl training set negative-control probe biological effect data iruv = TRUE. dataset must rows probes columns samples. also must number samples sample names biological.effect.tr. handling.effect.tr.ctrl training set negative-control probe handling effect data iruv = TRUE. dataset must rows probes columns samples. also must dimensions probe names biological.effect.tr.ctrl. norm.funcs list strings names user-defined normalization method functions, order norm.list, excluding built-normalization methods. class.funcs list strings names user-defined classification model-building functions, order class.list, excluding built-classification methods. pred.funcs list strings names user-defined classification predicting functions, order class.list, excluding built-classification methods. batch.id list array indices grouped batches data profiled. length list must equal number batches data; number array indices must number samples. required stratification study design specified design.list; otherwise batch.id = NULL.","code":""},{"path":"/reference/precision.simulate.class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"precision simulation with classification — precision.simulate.class","text":"simulation study results -- list array--sample assignments, fitted models, misclassification error rates across simulation runs: assign_store array--sample assignments study design, classified \"Train\" \"Test\" model_store models combination study designs, normalization methods, classification methods error_store internal external misclassification error rates combination study designs, normalization methods, classification methods, classfied \"Train\" \"Test\" ari_store adjusted rand index prediction test data","code":""},{"path":"/reference/precision.simulate.class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"precision simulation with classification — precision.simulate.class","text":"classification anlaysis simulation study consists following main steps: First, generation training test sets precision.simultate. precision.simulate.class requires training test sets estimated biological effects estimated handling effects. effects can simulated follows (using estimate.biological.effect estimate.handling.effect). uniformly-handled dataset used approximate biological effect sample, difference two arrays (one uniformly-handled dataset nonuniformly-handled dataset, subtracting former latter) sample used approximate handling effect array nonuniformly-handled dataset. samples randomly split training set test set, balanced tumor type (Qin et al., training--test ratio 2:1). arrays non-randomly split training set test set (Qin et al., training set n = 128 -- first 64 last 64 arrays order array processing; test set n = 64 -- middle 64 arrays). setup allows different pairings arrays samples various different training--test-set splits. Furthermore, biological signal strength confounding level handling effects can modified (using reduce.signal amplify.handling.effect). Second, apply \"virtual re-hybridization\" methods (using rehybridize) training test sets. 6 different methods choose, besides hybridization. also allowed produce different methods training set test set. specified train.design.met test.design.met. Third, apply normalization training test sets. three normalization methods choose training set, median normalization, quantile normalization variance stabilizing normalization. three methods, test set can processed method, corresponding frozen normalization pool normalization. Besides, sets can choose normalization. normalization methods specified train.norm.met test.norm.met. Data preprocessing batch effects can adjusted specified icombat, isva iruv. Fourth, choose classfication method, specified class.met. fit classification training set, 5-fold cross validation predict test set. internal external validation misclassificaiton error estimation, adjusted rand index test set included output. given split samples training set versus test set, N datasets simulated analyzed array-assignment scheme. user-defined normalization method classification method, please refer vignette.","code":""},{"path":"/reference/precision.simulate.class.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"precision simulation with classification — precision.simulate.class","text":"Qin LX, Huang HC, Begg CB. Cautionary note cross validation molecular classification. Journal Clinical Oncology. 2016","code":""},{"path":"/reference/precision.simulate.class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"precision simulation with classification — precision.simulate.class","text":"","code":"if (FALSE) { set.seed(101) biological.effect <- estimate.biological.effect(uhdata = uhdata.pl) handling.effect <- estimate.handling.effect(uhdata = uhdata.pl,                              nuhdata = nuhdata.pl)  ctrl.genes <- unique(rownames(uhdata.pl))[grep(\"NC\", unique(rownames(uhdata.pl)))]  biological.effect.nc <- biological.effect[!rownames(biological.effect) %in% ctrl.genes, ] handling.effect.nc <- handling.effect[!rownames(handling.effect) %in% ctrl.genes, ]  group.id <- substr(colnames(biological.effect.nc), 7, 7)  # randomly split biological effect data into training and test set with # equal number of endometrial and ovarian samples biological.effect.train.ind <- colnames(biological.effect.nc)[c(sample(which(group.id == \"E\"), size = 64),                                           sample(which(group.id == \"V\"), size = 64))] biological.effect.test.ind <- colnames(biological.effect.nc)[!colnames(biological.effect.nc) %in% biological.effect.train.ind] biological.effect.train.test.split =   list(\"tr\" = biological.effect.train.ind,        \"te\" = biological.effect.test.ind)  # non-randomly split handling effect data into training and test set handling.effect.train.test.split =   list(\"tr\" = c(1:64, 129:192),        \"te\" = 65:128)  biological.effect.nc.tr <- biological.effect.nc[, biological.effect.train.ind] biological.effect.nc.te <- biological.effect.nc[, biological.effect.test.ind] handling.effect.nc.tr <- handling.effect.nc[, c(1:64, 129:192)] handling.effect.nc.te <- handling.effect.nc[, 65:128]  # Simulation precision.result = precision.simulate.class(seed = 0, N = 3,                                             biological.effect.tr = biological.effect.nc.tr,                                             biological.effect.te = biological.effect.nc.te,                                             handling.effect.tr = handling.effect.nc.tr,                                             handling.effect.te = handling.effect.nc.te,                                             group.id.tr = substr(colnames(biological.effect.nc.tr), 7, 7),                                             group.id.te = substr(colnames(biological.effect.nc.te), 7, 7),                                             train.design.met = \"BLK\",                                             test.design.met = \"STR\",                                             train.norm.met = \"MN\",                                             test.norm.met = \"fMN\",                                             class.met = \"LASSO\",                                             train.batch.id = list(1:40, 41:64, (129:152)-64, (153:192)-64),                                             test.batch.id = list((65:80)-64,(81:114)-64,(115:128)-64))    }"},{"path":"/reference/precision.simulate.html","id":null,"dir":"Reference","previous_headings":"","what":"Classification analysis of simulation study — precision.simulate","title":"Classification analysis of simulation study — precision.simulate","text":"Perform simulation study Qin et al. (see reference).","code":""},{"path":"/reference/precision.simulate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Classification analysis of simulation study — precision.simulate","text":"","code":"# S3 method for simulate precision(   seed,   N,   biological.effect.tr,   biological.effect.te,   handling.effect.tr,   handling.effect.te,   group.id.tr,   group.id.te,   design.list = c(\"CC+\", \"CC-\", \"PC+\", \"PC-\"),   norm.list = c(\"NN\", \"QN\"),   class.list = c(\"PAM\", \"LASSO\"),   batch.id = NULL,   icombat = FALSE,   isva = FALSE,   iruv = FALSE,   biological.effect.tr.ctrl = NULL,   handling.effect.tr.ctrl = NULL,   norm.funcs = NULL,   class.funcs = NULL,   pred.funcs = NULL )"},{"path":"/reference/precision.simulate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Classification analysis of simulation study — precision.simulate","text":"seed integer used initialize pseudorandom number generator. N number simulation runs. biological.effect.tr training set estimated biological effects. dataset must rows probes columns samples. biological.effect.te test set estimated biological effects. dataset must rows probes columns samples. must number probes probe names training set estimated biological effects. handling.effect.tr training set estimated handling effects. dataset must rows probes columns samples. must dimensions probe names training set estimated biological effects. handling.effect.te test set estimated handling effects. dataset must rows probes, columns samples. must dimensions probe names training set estimated handling effects. group.id.tr vector sample-group labels sample training set estimated biological effects. must 2-level non-numeric factor vector. group.id.te vector sample-group labels sample test set estimated biological effects. must 2-level non-numeric factor vector. design.list list strings study designs compared simulation study. built-designs \"CC+\", \"CC-\", \"PC+\", \"PC-\", \"BLK\", \"STR\" \"Complete Confounding 1\", \"Complete Confounding 2\", \"Partial Confounding 1\", \"Partial Confounding 2\", \"Blocking\", \"Stratification\" Qin et al. norm.list list strings normalization methods compared simulation study. build-available normalization methods \"NN\", \"QN\", \"MN\", \"VSN\" \"Normalization\", \"Quantile Normalization\", \"Median Normalization\", \"Variance Stabilizing Normalization\". User can provide list normalization methods given functions supplied (also see norm.funcs). class.list list strings classification methods compared simulation study. built-classification methods \"PAM\" \"LASSO\" \"prediction analysis microarrays\" \"least absolute shrinkage selection operator\". User can provide list classification methods given correponding model-building predicting functions supplied (also see class.funcs pred.funcs). batch.id list array indices grouped batches data profiled. length list must equal number batches data; number array indices must number samples. required stratification study design specified design.list; otherwise batch.id = NULL. icombat indicator combat adjustment. default, icombat = FALSE ComBat adjustment. isva indicator sva adjustment. default, isva = FALSE sva adjustment. iruv indicator RUV-4 adjustment. default, iruv = FALSE RUV-4 adjustment. biological.effect.tr.ctrl training set negative-control probe biological effect data iruv = TRUE. dataset must rows probes columns samples. also must number samples sample names biological.effect.tr. handling.effect.tr.ctrl training set negative-control probe handling effect data iruv = TRUE. dataset must rows probes columns samples. also must dimensions probe names biological.effect.tr.ctrl. norm.funcs list strings names user-defined normalization method functions, order norm.list, excluding built-normalization methods. class.funcs list strings names user-defined classification model-building functions, order class.list, excluding built-classification methods. pred.funcs list strings names user-defined classification predicting functions, order class.list, excluding built-classification methods.","code":""},{"path":"/reference/precision.simulate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Classification analysis of simulation study — precision.simulate","text":"simulation study results -- list array--sample assignments, fitted models, misclassification error rates across simulation runs: assign_store array--sample assignments study design model_store models combination study designs, normalization methods, classification methods error_store internal external misclassification error rates combination study designs, normalization methods, classification methods","code":""},{"path":"/reference/precision.simulate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Classification analysis of simulation study — precision.simulate","text":"classification anlaysis simulation study consists following main steps: First, precision.simulate requires training test sets estimated biological effects estimated handling effects. effects can simulated follows (using estimate.biological.effect estimate.handling.effect). uniformly-handled dataset used approximate biological effect sample, difference two arrays (one uniformly-handled dataset nonuniformly-handled dataset, subtracting former latter) sample used approximate handling effect array nonuniformly-handled dataset. samples randomly split training set test set, balanced tumor type (Qin et al., training--test ratio 2:1). arrays non-randomly split training set test set (Qin et al., training set n = 128 -- first 64 last 64 arrays order array processing; test set n = 64 -- middle 64 arrays). setup allows different pairings arrays samples various different training--test-set splits. Furthermore, biological signal strength confounding level handling effects can modified (using reduce.signal amplify.handling.effect). Second, training set, data simulated \"virtual re-hybridization\" (using rehybridize) first assigning arrays sample groups using confounding design balanced design, summing biological effect sample handling effect assigned array. Rehybridization allows us examine use various array-assignment schemes, specified design.list. Third, analysis simulated dataset follows steps described analysis uniformly-handled data (also see documentation uni.handled.siumate): (1) data preprocessing (normalization methods specified norm.list batch effects can adjusted specified icombat, isva iruv) (2) classifier training (classification methods specified class.list) (3) classification error estimation using cross-validation external validation external validation based test data uniformly-handled dataset served gold standard misclassification error estimation. given split samples training set versus test set, N datasets simulated analyzed array-assignment scheme. user-defined normalization method classification method, please refer vignette.","code":""},{"path":"/reference/precision.simulate.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Classification analysis of simulation study — precision.simulate","text":"Qin LX, Huang HC, Begg CB. Cautionary note cross validation molecular classification. Journal Clinical Oncology. 2016","code":""},{"path":"/reference/precision.simulate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Classification analysis of simulation study — precision.simulate","text":"","code":"if (FALSE) { set.seed(101) biological.effect <- estimate.biological.effect(uhdata = uhdata.pl) handling.effect <- estimate.handling.effect(uhdata = uhdata.pl,                              nuhdata = nuhdata.pl)  ctrl.genes <- unique(rownames(uhdata.pl))[grep(\"NC\", unique(rownames(uhdata.pl)))]  biological.effect.nc <- biological.effect[!rownames(biological.effect) %in% ctrl.genes, ] handling.effect.nc <- handling.effect[!rownames(handling.effect) %in% ctrl.genes, ]  group.id <- substr(colnames(biological.effect.nc), 7, 7)  # randomly split biological effect data into training and test set with # equal number of endometrial and ovarian samples biological.effect.train.ind <- colnames(biological.effect.nc)[c(sample(which(group.id == \"E\"), size = 64),                                           sample(which(group.id == \"V\"), size = 64))] biological.effect.test.ind <- colnames(biological.effect.nc)[!colnames(biological.effect.nc) %in% biological.effect.train.ind] biological.effect.train.test.split =   list(\"tr\" = biological.effect.train.ind,        \"te\" = biological.effect.test.ind)  # non-randomly split handling effect data into training and test set handling.effect.train.test.split =   list(\"tr\" = c(1:64, 129:192),        \"te\" = 65:128)  biological.effect.nc.tr <- biological.effect.nc[, biological.effect.train.ind] biological.effect.nc.te <- biological.effect.nc[, biological.effect.test.ind] handling.effect.nc.tr <- handling.effect.nc[, c(1:64, 129:192)] handling.effect.nc.te <- handling.effect.nc[, 65:128]  # Simulation without batch adjustment precision.results <- precision.simulate(seed = 1, N = 3,                                         biological.effect.tr = biological.effect.nc.tr,                                         biological.effect.te = biological.effect.nc.te,                                         handling.effect.tr = handling.effect.nc.tr,                                         handling.effect.te = handling.effect.nc.te,                                         group.id.tr = substr(colnames(biological.effect.nc.tr), 7, 7),                                         group.id.te = substr(colnames(biological.effect.nc.te), 7, 7),                                         design.list = c(\"PC-\", \"STR\"),                                         norm.list = c(\"NN\", \"QN\"),                                         class.list = c(\"PAM\", \"LASSO\"),                                         batch.id = list(1:40,                                                         41:64,                                                         (129:160) - 64,                                                         (161:192) - 64))  # Simulation with RUV-4 batch adjustment biological.effect.ctrl <- biological.effect[rownames(biological.effect) %in% ctrl.genes, ] handling.effect.ctrl <- handling.effect[rownames(handling.effect) %in% ctrl.genes, ]  biological.effect.tr.ctrl <- biological.effect.ctrl[, biological.effect.train.test.split$tr] handling.effect.tr.ctrl <- handling.effect.ctrl[, handling.effect.train.test.split$tr]  precision.ruv4.results <- precision.simulate(seed = 1, N = 3,                                              biological.effect.tr = biological.effect.nc.tr,                                              biological.effect.te = biological.effect.nc.te,                                              handling.effect.tr = handling.effect.nc.tr,                                              handling.effect.te = handling.effect.nc.te,                                              group.id.tr = substr(colnames(biological.effect.nc.tr), 7, 7),                                              group.id.te = substr(colnames(biological.effect.nc.te), 7, 7),                                              design.list = c(\"PC-\", \"STR\"),                                              norm.list = c(\"NN\", \"QN\"),                                              class.list = c(\"PAM\", \"LASSO\"),                                              batch.id = list(1:40,                                                              41:64,                                                              (129:160) - 64,                                                              (161:192) - 64),                                              iruv = TRUE,                                              biological.effect.tr.ctrl = biological.effect.tr.ctrl,                                              handling.effect.tr.ctrl = handling.effect.tr.ctrl) }"},{"path":"/reference/precision.simulate.multiclass.html","id":null,"dir":"Reference","previous_headings":"","what":"precision simulation with multi-classification — precision.simulate.multiclass","title":"precision simulation with multi-classification — precision.simulate.multiclass","text":"Multi-Classification analysis applied different normalization study design. Perform simulation study Qin et al. (see reference).","code":""},{"path":"/reference/precision.simulate.multiclass.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"precision simulation with multi-classification — precision.simulate.multiclass","text":"","code":"# S3 method for simulate.multiclass precision(   seed,   N,   biological.effect.tr,   biological.effect.te,   handling.effect.tr,   handling.effect.te,   group.id.tr,   group.id.te,   train.design.met = \"NONE\",   test.design.met = \"NONE\",   train.norm.met = \"NN\",   test.norm.met = \"NN\",   class.list = c(\"SVM\", \"kNN\", \"LASSO\"),   train.batch.id = NULL,   test.batch.id = NULL,   icombat = FALSE,   isva = FALSE,   iruv = FALSE,   biological.effect.tr.ctrl = NULL,   handling.effect.tr.ctrl = NULL,   norm.funcs = NULL,   class.funcs = NULL,   pred.funcs = NULL )"},{"path":"/reference/precision.simulate.multiclass.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"precision simulation with multi-classification — precision.simulate.multiclass","text":"seed integer used initialize pseudorandom number generator. N number simulation runs. biological.effect.tr training set estimated biological effects. dataset must rows probes columns samples. biological.effect.te test set estimated biological effects. dataset must rows probes columns samples. must number probes probe names training set estimated biological effects. handling.effect.tr training set estimated handling effects. dataset must rows probes columns samples. must dimensions probe names training set estimated biological effects. handling.effect.te test set estimated handling effects. dataset must rows probes, columns samples. must dimensions probe names training set estimated handling effects. group.id.tr vector sample-group labels sample training set estimated biological effects. must 2-level non-numeric factor vector. group.id.te vector sample-group labels sample test set estimated biological effects. must 2-level non-numeric factor vector. train.design.met string study design applied training set. built-designs \"NONE\", CC+\", \"CC-\", \"PC+\", \"PC-\", \"BLK\", \"STR\" \"Rehybridization\", \"Complete Confounding 1\", \"Complete Confounding 2\", \"Partial Confounding 1\", \"Partial Confounding 2\", \"Blocking\", \"Stratification\" Qin et al. test.design.met string study design applied test set. built-designs \"NONE\", CC+\", \"CC-\", \"PC+\", \"PC-\", \"BLK\", \"STR\" \"Rehybridization\", \"Complete Confounding 1\", \"Complete Confounding 2\", \"Partial Confounding 1\", \"Partial Confounding 2\", \"Blocking\", \"Stratification\" Qin et al. train.norm.met string normalization method applied training set. build-available normalization methods \"NN\", \"QN\", \"MN\", \"VSN\" \"Normalization\", \"Quantile Normalization\", \"Median Normalization\", \"Variance Stabilizing Normalization\". User can provide list normalization methods given functions supplied (also see norm.funcs). test.norm.met string normalization method applied test set. build-available normalization methods \"NN\", \"MN\", \"QN\", \"fMN\", \"fQN\", \"pMN\", \"pQN\", \"fVSN\", \"Normalization\", \"Median Normalization\", \"Quantile Normalization\", \"Frozen Median Normalization\", \"Frozen Quantile Normalization\", \"Pool Median Normalization\", \"Pool Quantile Normalization\", \"Frozen Vairance Stability Normalization\". User can provide list normalization methods given functions supplied (also see norm.funcs). class.list list strings classification methods compared simulation study. build-available classfication methods \"PAM\", \"LASSO\", \"ClaNC\", \"ranFor\", \"SVM\", \"kNN\" \"DLDA\", \"Prediction Analysis Microarrays\", \"Least Absolute Shrinkage Selection Operator\", \"Classification Nearest Centroids\", \"Random Forest\", \"Support Vector Machine\", \"K-Nearest Neighbors\" \"Diagonal Linear Discriminant\". User can provide list classification methods given correponding model-building predicting functions supplied (also see class.funcs pred.funcs). can also use classification method setting class.met \"custom\". format create custom.intcv custom.predict please refers classification methods package. icombat indicator combat adjustment. default, icombat = FALSE ComBat adjustment. isva indicator sva adjustment. default, isva = FALSE sva adjustment. iruv indicator RUV-4 adjustment. default, iruv = FALSE RUV-4 adjustment. biological.effect.tr.ctrl training set negative-control probe biological effect data iruv = TRUE. dataset must rows probes columns samples. also must number samples sample names biological.effect.tr. handling.effect.tr.ctrl training set negative-control probe handling effect data iruv = TRUE. dataset must rows probes columns samples. also must dimensions probe names biological.effect.tr.ctrl. norm.funcs list strings names user-defined normalization method functions, order norm.list, excluding built-normalization methods. class.funcs list strings names user-defined classification model-building functions, order class.list, excluding built-classification methods. pred.funcs list strings names user-defined classification predicting functions, order class.list, excluding built-classification methods. batch.id list array indices grouped batches data profiled. length list must equal number batches data; number array indices must number samples. required stratification study design specified design.list; otherwise batch.id = NULL.","code":""},{"path":"/reference/precision.simulate.multiclass.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"precision simulation with multi-classification — precision.simulate.multiclass","text":"simulation study results -- list array--sample assignments, fitted models, misclassification error rates across simulation runs: assign_store array--sample assignments study design, classified \"Train\" \"Test\" model_store models combination study designs, normalization methods, classification methods error_store internal external misclassification error rates combination study designs, normalization methods, classification methods, classfied \"Train\" \"Test\" ari_store adjusted rand index prediction test data","code":""},{"path":"/reference/precision.simulate.multiclass.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"precision simulation with multi-classification — precision.simulate.multiclass","text":"classification anlaysis simulation study consists following main steps: First, generation training test sets precision.simultate. precision.simulate.multiclass requires training test sets estimated biological effects estimated handling effects. effects can simulated follows (using estimate.biological.effect estimate.handling.effect). uniformly-handled dataset used approximate biological effect sample, difference two arrays (one uniformly-handled dataset nonuniformly-handled dataset, subtracting former latter) sample used approximate handling effect array nonuniformly-handled dataset. samples randomly split training set test set, balanced tumor type (Qin et al., training--test ratio 2:1). arrays non-randomly split training set test set (Qin et al., training set n = 128 -- first 64 last 64 arrays order array processing; test set n = 64 -- middle 64 arrays). setup allows different pairings arrays samples various different training--test-set splits. Furthermore, biological signal strength confounding level handling effects can modified (using reduce.signal amplify.handling.effect). Second, apply \"virtual re-hybridization\" methods (using rehybridize) training test sets. 6 different methods choose, besides hybridization. also allowed produce different methods training set test set. specified train.design.met test.design.met. Third, apply normalization training test sets. three normalization methods choose training set, median normalization, quantile normalization variance stabilizing normalization. three methods, test set can processed method, corresponding frozen normalization pool normalization. Besides, sets can choose normalization. normalization methods specified train.norm.met test.norm.met. Data preprocessing batch effects can adjusted specified icombat, isva iruv. Fourth, choose classfication methods, specified  class.list. fit chosen classification methods training set, 5-fold cross validation predict test set. internal external validation misclassificaiton error estimation, adjusted rand index test set included output. given split samples training set versus test set, N datasets simulated analyzed array-assignment scheme. user-defined normalization method classification method, please refer vignette.","code":""},{"path":"/reference/precision.simulate.multiclass.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"precision simulation with multi-classification — precision.simulate.multiclass","text":"Qin LX, Huang HC, Begg CB. Cautionary note cross validation molecular classification. Journal Clinical Oncology. 2016","code":""},{"path":"/reference/precision.simulate.multiclass.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"precision simulation with multi-classification — precision.simulate.multiclass","text":"","code":"if (FALSE) { set.seed(101) biological.effect <- estimate.biological.effect(uhdata = uhdata.pl) handling.effect <- estimate.handling.effect(uhdata = uhdata.pl,                              nuhdata = nuhdata.pl)  ctrl.genes <- unique(rownames(uhdata.pl))[grep(\"NC\", unique(rownames(uhdata.pl)))]  biological.effect.nc <- biological.effect[!rownames(biological.effect) %in% ctrl.genes, ] handling.effect.nc <- handling.effect[!rownames(handling.effect) %in% ctrl.genes, ]  group.id <- substr(colnames(biological.effect.nc), 7, 7)  # randomly split biological effect data into training and test set with # equal number of endometrial and ovarian samples biological.effect.train.ind <- colnames(biological.effect.nc)[c(sample(which(group.id == \"E\"), size = 64),                                           sample(which(group.id == \"V\"), size = 64))] biological.effect.test.ind <- colnames(biological.effect.nc)[!colnames(biological.effect.nc) %in% biological.effect.train.ind] biological.effect.train.test.split =   list(\"tr\" = biological.effect.train.ind,        \"te\" = biological.effect.test.ind)  # non-randomly split handling effect data into training and test set handling.effect.train.test.split =   list(\"tr\" = c(1:64, 129:192),        \"te\" = 65:128)  biological.effect.nc.tr <- biological.effect.nc[, biological.effect.train.ind] biological.effect.nc.te <- biological.effect.nc[, biological.effect.test.ind] handling.effect.nc.tr <- handling.effect.nc[, c(1:64, 129:192)] handling.effect.nc.te <- handling.effect.nc[, 65:128]  # Simulation precision.result = precision.simulate.multiclass(seed = 0, N = 3,                                             biological.effect.tr = biological.effect.nc.tr,                                             biological.effect.te = biological.effect.nc.te,                                             handling.effect.tr = handling.effect.nc.tr,                                             handling.effect.te = handling.effect.nc.te,                                             group.id.tr = substr(colnames(biological.effect.nc.tr), 7, 7),                                             group.id.te = substr(colnames(biological.effect.nc.te), 7, 7),                                             train.design.met = \"BLK\",                                             test.design.met = \"STR\",                                             train.norm.met = \"MN\",                                             test.norm.met = \"fMN\",                                             class.list = c(\"SVM\", \"kNN\", \"LASSO\"),                                             train.batch.id = list(1:40, 41:64, (129:152)-64, (153:192)-64),                                             test.batch.id = list((65:80)-64,(81:114)-64,(115:128)-64))    }"},{"path":"/reference/quant.norm.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantile normalization — quant.norm","title":"Quantile normalization — quant.norm","text":"Normalize training dataset quantile normalization store quantiles training dataset references frozen quantile normalize test dataset.","code":""},{"path":"/reference/quant.norm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantile normalization — quant.norm","text":"","code":"quant.norm(train = NULL, test = NULL, ref.dis = NULL)"},{"path":"/reference/quant.norm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantile normalization — quant.norm","text":"train training dataset quantile normalized. dataset must rows probes columns samples. can left unspecified ref.dis suppied frozen normalize test set. test test dataset frozen quantile normalized. dataset must rows probes columns samples. number rows must equal number rows training set. default, test set specified (test = NULL) frozen normalization performed. ref.dis reference distribution frozen quantile normalize test set previously normalized training set. required train supplied. default, ref.dis = NULL.","code":""},{"path":"/reference/quant.norm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantile normalization — quant.norm","text":"list two datasets one reference distribution: train.mn normalized training set test.fmn frozen normalized test set, test set specified ref.dis reference distribution","code":""},{"path":"/reference/quant.norm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Quantile normalization — quant.norm","text":"Bolstad, B. M., Irizarry R. ., Astrand, M, Speed, T. P. (2003) Comparison Normalization Methods High Density Oligonucleotide Array Data Based Bias Variance. Bioinformatics 19(2) , pp 185-193. http://bmbolstad.com/misc/normalize/normalize.html","code":""},{"path":"/reference/quant.norm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quantile normalization — quant.norm","text":"","code":"set.seed(101) group.id <- substr(colnames(nuhdata.pl), 7, 7) train.ind <- colnames(nuhdata.pl)[c(sample(which(group.id == \"E\"), size = 64),                                sample(which(group.id == \"V\"), size = 64))] train.dat <- nuhdata.pl[, train.ind] test.dat <- nuhdata.pl[, !colnames(nuhdata.pl) %in% train.ind]  # normalize only training set data.qn <- quant.norm(train = train.dat) str(data.qn) #> List of 3 #>  $ train.qn: num [1:1810, 1:128] 7.26 7.15 6.94 7.22 7.16 ... #>   ..- attr(*, \"dimnames\")=List of 2 #>   .. ..$ : chr [1:1810] \"A_25_P00011991\" \"A_25_P00011991\" \"A_25_P00011991\" \"A_25_P00011991\" ... #>   .. ..$ : chr [1:128] \"GL5140E\" \"JB5556E\" \"JB4783E\" \"GL4527E\" ... #>  $ test.fqn: NULL #>  $ ref.dis : num [1:1810] 4.15 4.24 4.29 4.32 4.35 ...  # normalize training set and frozen normalize test set data.qn <- quant.norm(train = train.dat, test = test.dat) str(data.qn) #> List of 3 #>  $ train.qn: num [1:1810, 1:128] 7.26 7.15 6.94 7.22 7.16 ... #>   ..- attr(*, \"dimnames\")=List of 2 #>   .. ..$ : chr [1:1810] \"A_25_P00011991\" \"A_25_P00011991\" \"A_25_P00011991\" \"A_25_P00011991\" ... #>   .. ..$ : chr [1:128] \"GL5140E\" \"JB5556E\" \"JB4783E\" \"GL4527E\" ... #>  $ test.fqn: num [1:1810, 1:64] 6.31 6.7 7.01 5.83 5.98 ... #>   ..- attr(*, \"dimnames\")=List of 2 #>   .. ..$ : chr [1:1810] \"A_25_P00011991\" \"A_25_P00011991\" \"A_25_P00011991\" \"A_25_P00011991\" ... #>   .. ..$ : chr [1:64] \"JB4166E\" \"JB5669E\" \"JB4112E\" \"JB5847E\" ... #>  $ ref.dis : num [1:1810] 4.15 4.24 4.29 4.32 4.35 ...  # frozen normalize test set with reference distribution ref <- quant.norm(train = train.dat)$ref.dis data.qn <- quant.norm(test = test.dat, ref.dis = ref) str(data.qn) #> List of 3 #>  $ train.qn: NULL #>  $ test.fqn: num [1:1810, 1:64] 6.31 6.7 7.01 5.83 5.98 ... #>   ..- attr(*, \"dimnames\")=List of 2 #>   .. ..$ : chr [1:1810] \"A_25_P00011991\" \"A_25_P00011991\" \"A_25_P00011991\" \"A_25_P00011991\" ... #>   .. ..$ : chr [1:64] \"JB4166E\" \"JB5669E\" \"JB4112E\" \"JB5847E\" ... #>  $ ref.dis : num [1:1810] 4.15 4.24 4.29 4.32 4.35 ..."},{"path":"/reference/ranfor.intcv.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Forest  Classifier — ranfor.intcv","title":"Random Forest  Classifier — ranfor.intcv","text":"Build random forest classifier using internal cross validation choose turning parameter, 5-fold cross validation default.","code":""},{"path":"/reference/ranfor.intcv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Forest  Classifier — ranfor.intcv","text":"","code":"ranfor.intcv(kfold = 5, X, y, seed)"},{"path":"/reference/ranfor.intcv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Forest  Classifier — ranfor.intcv","text":"kfold number folds. default, kfold = 5. X dataset trained. dataset must rows probes columns samples. y vector sample group sample dataset trained. must equal length number samples X. seed integer used initialize pseudorandom number generator.","code":""},{"path":"/reference/ranfor.intcv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Forest  Classifier — ranfor.intcv","text":"list 4 elements: mc internal misclassification error rate time processing time performing internal validation LASSO model LASSO classifier, resulted cv.fit","code":""},{"path":"/reference/ranfor.intcv.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Random Forest  Classifier — ranfor.intcv","text":"https://cran.r-project.org/web/packages/e1071/index.html","code":""},{"path":"/reference/ranfor.intcv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Forest  Classifier — ranfor.intcv","text":"","code":"set.seed(101) biological.effect <- estimate.biological.effect(uhdata = uhdata.pl) ctrl.genes <- unique(rownames(uhdata.pl))[grep(\"NC\", unique(rownames(uhdata.pl)))] biological.effect.nc <- biological.effect[!rownames(biological.effect)   %in% ctrl.genes, ] group.id <- substr(colnames(biological.effect.nc), 7, 7)  biological.effect.train.ind <- colnames(biological.effect.nc)[c(sample(which(   group.id == \"E\"), size = 64),   sample(which(group.id == \"V\"), size = 64))] biological.effect.nc.tr <- biological.effect.nc[, biological.effect.train.ind]  ranfor.int <- ranfor.intcv(X = biological.effect.nc.tr,                          y = substr(colnames(biological.effect.nc.tr), 7, 7),                          kfold = 5, seed = 1) #> mtry = 41  OOB error = 16.41%  #> Searching left ... #> mtry = 21 \tOOB error = 15.62%  #> 0.04761905 0.05  #> Searching right ... #> mtry = 82 \tOOB error = 20.31%  #> -0.2380952 0.05   #> [1] 0.140625"},{"path":"/reference/ranfor.predict.html","id":null,"dir":"Reference","previous_headings":"","what":"Prediction with random forest classifier — ranfor.predict","title":"Prediction with random forest classifier — ranfor.predict","text":"Predict ranfom forest classifier fit.","code":""},{"path":"/reference/ranfor.predict.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prediction with random forest classifier — ranfor.predict","text":"","code":"ranfor.predict(ranfor.intcv.model, pred.obj, pred.obj.group.id)"},{"path":"/reference/ranfor.predict.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prediction with random forest classifier — ranfor.predict","text":"ranfor.intcv.model ranfom forest classifier built ranfor.intcv. pred.obj dataset sample group predicted. dataset must rows probes columns samples. must equal number probes dataset trained. pred.obj.group.id vector sample-group labels sample dataset predicted. must equal length number samples pred.obj.","code":""},{"path":"/reference/ranfor.predict.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prediction with random forest classifier — ranfor.predict","text":"list 3 elements: pred predicted sample group sample mc predicted misclassification error rate (external validation) prob predicted probability sample","code":""},{"path":"/reference/ranfor.predict.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Prediction with random forest classifier — ranfor.predict","text":"https://cran.r-project.org/web/packages/e1071/index.html","code":""},{"path":"/reference/ranfor.predict.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prediction with random forest classifier — ranfor.predict","text":"","code":"set.seed(101) biological.effect <- estimate.biological.effect(uhdata = uhdata.pl) ctrl.genes <- unique(rownames(uhdata.pl))[grep(\"NC\", unique(rownames(uhdata.pl)))] biological.effect.nc <- biological.effect[!rownames(biological.effect) %in% ctrl.genes, ] group.id <- substr(colnames(biological.effect.nc), 7, 7)  biological.effect.train.ind <- colnames(biological.effect.nc)[c(sample(which(group.id == \"E\"), size = 64),                                           sample(which(group.id == \"V\"), size = 64))] biological.effect.test.ind <- colnames(biological.effect.nc)[!colnames(biological.effect.nc) %in% biological.effect.train.ind]  biological.effect.nc.tr <- biological.effect.nc[, biological.effect.train.ind] biological.effect.nc.te <- biological.effect.nc[, biological.effect.test.ind]  ranfor.int <- ranfor.intcv(X = biological.effect.nc.tr,                          y = substr(colnames(biological.effect.nc.tr), 7, 7),                          kfold = 5, seed = 1) #> mtry = 41  OOB error = 16.41%  #> Searching left ... #> mtry = 21 \tOOB error = 15.62%  #> 0.04761905 0.05  #> Searching right ... #> mtry = 82 \tOOB error = 20.31%  #> -0.2380952 0.05   #> [1] 0.140625  ranfor.pred <- ranfor.predict(ranfor.intcv.model = ranfor.int,                             pred.obj = biological.effect.nc.te,                             pred.obj.group.id = substr(colnames(biological.effect.nc.te), 7, 7)) ranfor.int$mc #> [1] 0.140625 ranfor.pred$mc #> [1] 0.109375"},{"path":"/reference/reduce.signal.html","id":null,"dir":"Reference","previous_headings":"","what":"Biological signal reduction — reduce.signal","title":"Biological signal reduction — reduce.signal","text":"Reduce biological signal decreasing mean group difference sample groups.","code":""},{"path":"/reference/reduce.signal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Biological signal reduction — reduce.signal","text":"","code":"reduce.signal(   biological.effect,   group.id,   group.id.level = c(\"E\", \"V\"),   reduce.multiplier = 1/2,   pbset.id = NULL )"},{"path":"/reference/reduce.signal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Biological signal reduction — reduce.signal","text":"biological.effect estimated biological effect dataset. dataset must rows probes columns samples. can take probe-level dataset fixed number probes per unique probe-set. group.id vector sample-group labels sample estimated biological effect dataset. group.id.level vector sample-group label level. must two two elements first element reference. default, group.id.level = c(\"E\", \"V\"). study, compare endometrial tumor samples ovarian tumor samples, endometrial reference. reduce.multiplier multiplier specified reduce -sample-group signal . default, reduce.multiplier = 1/2. pbset.id vector unique probe-set names. specified, unique probe names dataset, extracting row names.","code":""},{"path":"/reference/reduce.signal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Biological signal reduction — reduce.signal","text":"estimated biological effect data, reduced biological signal","code":""},{"path":"/reference/reduce.signal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Biological signal reduction — reduce.signal","text":"","code":"biological.effect <- estimate.biological.effect(uhdata = uhdata.pl) handling.effect <- estimate.handling.effect(uhdata = uhdata.pl,                              nuhdata = nuhdata.pl)  ctrl.genes <- unique(rownames(uhdata.pl))[grep(\"NC\", unique(rownames(uhdata.pl)))]  biological.effect.nc <- biological.effect[!rownames(biological.effect) %in% ctrl.genes, ] handling.effect.nc <- handling.effect[!rownames(handling.effect) %in% ctrl.genes, ] group.id <- substr(colnames(biological.effect.nc), 7, 7)  redhalf.biological.effect.nc <- reduce.signal(biological.effect = biological.effect.nc,                                     group.id = group.id,                                     group.id.level = c(\"E\", \"V\"),                                     reduce.multiplier = 1/2)"},{"path":"/reference/rehybridize.html","id":null,"dir":"Reference","previous_headings":"","what":"Virtual rehybridization with an array-to-sample assignment — rehybridize","title":"Virtual rehybridization with an array-to-sample assignment — rehybridize","text":"Create simulated dataset \"virtual rehybridization\" given array--sample assignment.","code":""},{"path":"/reference/rehybridize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Virtual rehybridization with an array-to-sample assignment — rehybridize","text":"","code":"rehybridize(   biological.effect,   handling.effect,   group.id,   group.id.level = c(\"E\", \"V\"),   array.to.sample.assign,   icombat = FALSE,   isva = FALSE,   iruv = FALSE,   biological.effect.ctrl = NULL,   handling.effect.ctrl = NULL )"},{"path":"/reference/rehybridize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Virtual rehybridization with an array-to-sample assignment — rehybridize","text":"biological.effect estimated biological effect dataset. dataset must rows probes columns samples. handling.effect estimated handling effect dataset. dataset must rows probes columns samples. must dimensions probe names estimated biological effect dataset. group.id vector sample-group labels sample estimated biological effect dataset. must 2-level non-numeric factor vector. group.id.level vector sample-group label level. must two two elements first element reference. default, group.id.level = c(\"E\", \"V\"). study, compare endometrial tumor samples ovarian tumor samples, endometrial reference. array..sample.assign vector indices assign arrays samples (see details blocking.design, confounding.design stratification.design). must equal length number samples estimated biological effect dataset. first half arrays vector assigned sample group 1 second half sample group 2. icombat indicator combat adjustment. default, icombat = FALSE ComBat adjustment. isva indicator sva adjustment. default, isva = FALSE sva adjustment. iruv indicator RUV-4 adjustment. default, iruv = FALSE RUV-4 adjustment. biological.effect.ctrl negative-control probe biological effect data iruv = TRUE. dataset must rows probes columns samples. also must number samples sample names biological.effect. handling.effect.ctrl negative-control probe handling effect data iruv = TRUE. also must dimensions probe names biological.effect.ctrl.","code":""},{"path":"/reference/rehybridize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Virtual rehybridization with an array-to-sample assignment — rehybridize","text":"simulated data, batch adjustment specified","code":""},{"path":"/reference/rehybridize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Virtual rehybridization with an array-to-sample assignment — rehybridize","text":"","code":"if (FALSE) { biological.effect <- estimate.biological.effect(uhdata = uhdata.pl) handling.effect <- estimate.handling.effect(uhdata = uhdata.pl,                              nuhdata = nuhdata.pl)  ctrl.genes <- unique(rownames(uhdata.pl))[grep(\"NC\", unique(rownames(uhdata.pl)))]  biological.effect.nc <- biological.effect[!rownames(biological.effect) %in% ctrl.genes, ] handling.effect.nc <- handling.effect[!rownames(handling.effect) %in% ctrl.genes, ]  assign.ind <- confounding.design(seed = 1, num.array = 192, degree = \"complete\", rev.order = FALSE)  group.id <- substr(colnames(biological.effect.nc), 7, 7)  # no batch effect adjustment (default) sim.data.raw <- rehybridize(biological.effect = biological.effect.nc,                             handling.effect = handling.effect.nc,                             group.id = group.id,                             array.to.sample.assign = assign.ind)  # batch effect adjusting with sva sim.data.sva <- rehybridize(biological.effect = biological.effect.nc,                             handling.effect = handling.effect.nc,                             group.id = group.id,                             array.to.sample.assign = assign.ind,                             isva = TRUE)  # batch effect adjusting with RUV-4 biological.effect.ctrl <- biological.effect[rownames(biological.effect) %in% ctrl.genes, ] handling.effect.ctrl <- handling.effect[rownames(handling.effect) %in% ctrl.genes, ]  sim.data.ruv <- rehybridize(biological.effect = biological.effect.nc,                             handling.effect = handling.effect.nc,                             group.id = group.id,                             array.to.sample.assign = assign.ind,                             iruv = TRUE,                             biological.effect.ctrl = biological.effect.ctrl,                             handling.effect.ctrl = handling.effect.ctrl) }"},{"path":"/reference/stratification.design.html","id":null,"dir":"Reference","previous_headings":"","what":"Stratification Design — stratification.design","title":"Stratification Design — stratification.design","text":"Assign arrays samples stratification, study design assigning arrays batch sample group proportionally.","code":""},{"path":"/reference/stratification.design.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stratification Design — stratification.design","text":"","code":"stratification.design(seed, num.array, batch.id)"},{"path":"/reference/stratification.design.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stratification Design — stratification.design","text":"seed integer used initialize pseudorandom number generator. num.array number arrays. batch.id list array indices grouped batches data profiled. length list must equal number batches data; number array indices must number samples.","code":""},{"path":"/reference/stratification.design.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stratification Design — stratification.design","text":"vector array IDs order assigning samples assumed sorted sample group interest result, first half array IDs assigned group 1 second half array IDs assigned group 2.","code":""},{"path":"/reference/stratification.design.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stratification Design — stratification.design","text":"","code":"batch.id <- list(1:40, 41:64, (129:160) - 64, (161:192) - 64) str.ind <- stratification.design(seed = 1, num.array = 128,                                  batch.id = batch.id)"},{"path":"/reference/svm.intcv.html","id":null,"dir":"Reference","previous_headings":"","what":"Support Vector Machine  Classifier — svm.intcv","title":"Support Vector Machine  Classifier — svm.intcv","text":"Build support vactor machine classifier using internal cross validation choose turning parameter, 5-fold cross validation default.","code":""},{"path":"/reference/svm.intcv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Support Vector Machine  Classifier — svm.intcv","text":"","code":"# S3 method for intcv svm(kfold = 5, X, y, seed)"},{"path":"/reference/svm.intcv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Support Vector Machine  Classifier — svm.intcv","text":"kfold number folds. default, kfold = 5. X dataset trained. dataset must rows probes columns samples. y vector sample group sample dataset trained. must equal length number samples X. seed integer used initialize pseudorandom number generator.","code":""},{"path":"/reference/svm.intcv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Support Vector Machine  Classifier — svm.intcv","text":"list 4 elements: mc internal misclassification error rate time processing time performing internal validation SVM model SVM classifier, resulted cv.fit","code":""},{"path":"/reference/svm.intcv.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Support Vector Machine  Classifier — svm.intcv","text":"https://cran.r-project.org/web/packages/e1071/index.html","code":""},{"path":"/reference/svm.intcv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Support Vector Machine  Classifier — svm.intcv","text":"","code":"set.seed(101) biological.effect <- estimate.biological.effect(uhdata = uhdata.pl) ctrl.genes <- unique(rownames(uhdata.pl))[grep(\"NC\", unique(rownames(uhdata.pl)))] biological.effect.nc <- biological.effect[!rownames(biological.effect)   %in% ctrl.genes, ] group.id <- substr(colnames(biological.effect.nc), 7, 7)  biological.effect.train.ind <- colnames(biological.effect.nc)[c(sample(which(   group.id == \"E\"), size = 64),   sample(which(group.id == \"V\"), size = 64))] biological.effect.nc.tr <- biological.effect.nc[, biological.effect.train.ind]  svm.int <- svm.intcv(X = biological.effect.nc.tr,                      y = substr(colnames(biological.effect.nc.tr), 7, 7),                      kfold = 5, seed = 1)"},{"path":"/reference/svm.predict.html","id":null,"dir":"Reference","previous_headings":"","what":"Prediction with support vector machine classifier — svm.predict","title":"Prediction with support vector machine classifier — svm.predict","text":"Predict support vector machine classifier fit.","code":""},{"path":"/reference/svm.predict.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prediction with support vector machine classifier — svm.predict","text":"","code":"# S3 method for predict svm(svm.intcv.model, pred.obj, pred.obj.group.id)"},{"path":"/reference/svm.predict.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prediction with support vector machine classifier — svm.predict","text":"svm.intcv.model support vector machine classifier built svm.intcv. pred.obj dataset sample group predicted. dataset must rows probes columns samples. must equal number probes dataset trained. pred.obj.group.id vector sample-group labels sample dataset predicted. must equal length number samples pred.obj.","code":""},{"path":"/reference/svm.predict.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prediction with support vector machine classifier — svm.predict","text":"list 3 elements: pred predicted sample group sample mc predicted misclassification error rate (external validation) prob predicted probability sample","code":""},{"path":"/reference/svm.predict.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Prediction with support vector machine classifier — svm.predict","text":"https://cran.r-project.org/web/packages/e1071/index.html","code":""},{"path":"/reference/svm.predict.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prediction with support vector machine classifier — svm.predict","text":"","code":"set.seed(101) biological.effect <- estimate.biological.effect(uhdata = uhdata.pl) ctrl.genes <- unique(rownames(uhdata.pl))[grep(\"NC\", unique(rownames(uhdata.pl)))] biological.effect.nc <- biological.effect[!rownames(biological.effect) %in% ctrl.genes, ] group.id <- substr(colnames(biological.effect.nc), 7, 7)  biological.effect.train.ind <- colnames(biological.effect.nc)[c(sample(which(group.id == \"E\"), size = 64),                                           sample(which(group.id == \"V\"), size = 64))] biological.effect.test.ind <- colnames(biological.effect.nc)[!colnames(biological.effect.nc) %in% biological.effect.train.ind]  biological.effect.nc.tr <- biological.effect.nc[, biological.effect.train.ind] biological.effect.nc.te <- biological.effect.nc[, biological.effect.test.ind]  svm.int <- svm.intcv(X = biological.effect.nc.tr,                      y = substr(colnames(biological.effect.nc.tr), 7, 7),                      kfold = 5, seed = 1)  svm.pred <- svm.predict(svm.intcv.model = svm.int,                         pred.obj = biological.effect.nc.te,                         pred.obj.group.id = substr(colnames(biological.effect.nc.te), 7, 7)) svm.int$mc #> [1] 0.2033846 svm.pred$mc #> [1] 0.125"},{"path":"/reference/switch.classifier.funcs.class.html","id":null,"dir":"Reference","previous_headings":"","what":"Switch classfication functions — switch.classifier.funcs.class","title":"Switch classfication functions — switch.classifier.funcs.class","text":"Transform classfication method names fitting function name prediction function name, using classfication procedure","code":""},{"path":"/reference/switch.classifier.funcs.class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Switch classfication functions — switch.classifier.funcs.class","text":"","code":"switch.classifier.funcs.class(   class.list = c(\"PAM\", \"LASSO\", \"ClaNC\", \"ranFor\", \"SVM\", \"kNN\", \"DLDA\", \"custom\"),   class.funcs = NULL,   pred.funcs = NULL )"},{"path":"/reference/switch.classifier.funcs.class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Switch classfication functions — switch.classifier.funcs.class","text":"class.list list classification method name transformed. build-methods \"PAM\", \"LASSO\", \"ClaNC\", \"ranFor\", \"SVM\", \"kNN\" \"DLDA\". class.funcs classfication functions users can create . pred.funcs prediction funcstions users can create .","code":""},{"path":"/reference/switch.classifier.funcs.class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Switch classfication functions — switch.classifier.funcs.class","text":"list containing build.funcs, means fitting function names, pred.funcs, means prediction function names. fitting functions fitted training set prediction function used test set.","code":""},{"path":"/reference/switch.classifier.funcs.class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Switch classfication functions — switch.classifier.funcs.class","text":"switch.classifier.funcs.class","code":""},{"path":"/reference/switch.classifier.funcs.class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Switch classfication functions — switch.classifier.funcs.class","text":"","code":"switch.classifier.funcs.class(class.list = c(\"PAM\", \"LASSO\", \"ClaNC\", \"ranFor\", \"SVM\"), class.funcs = NULL, pred.funcs = NULL) #> $build.funcs #> [1] \"pam.intcv\"    \"lasso.intcv\"  \"clanc.intcv\"  \"ranfor.intcv\" \"svm.intcv\"    #>  #> $pred.funcs #> [1] \"pam.predict\"    \"lasso.predict\"  \"clanc.predict\"  \"ranfor.predict\" \"svm.predict\"    #>"},{"path":"/reference/switch.classifier.funcs.html","id":null,"dir":"Reference","previous_headings":"","what":"Switch classfication functions — switch.classifier.funcs","title":"Switch classfication functions — switch.classifier.funcs","text":"Transform classfication method names fitting function name prediction function name, using classfication procedure","code":""},{"path":"/reference/switch.classifier.funcs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Switch classfication functions — switch.classifier.funcs","text":"","code":"switch.classifier.funcs(   class.list = c(\"PAM\", \"LASSO\"),   class.funcs = NULL,   pred.funcs = NULL )"},{"path":"/reference/switch.classifier.funcs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Switch classfication functions — switch.classifier.funcs","text":"class.list list classification method name transformed. build-methods \"PAM\" \"LASSO\". class.funcs classfication functions users can create . pred.funcs prediction funcstions users can create .","code":""},{"path":"/reference/switch.classifier.funcs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Switch classfication functions — switch.classifier.funcs","text":"list containing build.funcs, means fitting function names, pred.funcs, means prediction function names. fitting functions fitted training set prediction function used test set.","code":""},{"path":"/reference/switch.classifier.funcs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Switch classfication functions — switch.classifier.funcs","text":"switch.classifier.funcs","code":""},{"path":"/reference/switch.classifier.funcs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Switch classfication functions — switch.classifier.funcs","text":"","code":"switch.classifier.funcs.class(class.list =  c(\"PAM\", \"LASSO\"),                               class.funcs = NULL, pred.funcs = NULL) #> $build.funcs #> [1] \"pam.intcv\"   \"lasso.intcv\" #>  #> $pred.funcs #> [1] \"pam.predict\"   \"lasso.predict\" #>"},{"path":"/reference/switch.norm.funcs.flex.html","id":null,"dir":"Reference","previous_headings":"","what":"Switch normalization funcsions in a flexible way — switch.norm.funcs.flex","title":"Switch normalization funcsions in a flexible way — switch.norm.funcs.flex","text":"Transform normalization method names functions names, running normalization procedure","code":""},{"path":"/reference/switch.norm.funcs.flex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Switch normalization funcsions in a flexible way — switch.norm.funcs.flex","text":"","code":"switch.norm.funcs.flex(norm.list = c(\"NN\", \"QN\"), norm.funcs = NULL)"},{"path":"/reference/switch.norm.funcs.flex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Switch normalization funcsions in a flexible way — switch.norm.funcs.flex","text":"norm.list Switch build-normalization methods function names, including \"NN\", \"MN\", \"QN\", \"VSN\". norm.funcs New functions user can create .","code":""},{"path":"/reference/switch.norm.funcs.flex.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Switch normalization funcsions in a flexible way — switch.norm.funcs.flex","text":"list transforms normalization method name function name.","code":""},{"path":"/reference/switch.norm.funcs.flex.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Switch normalization funcsions in a flexible way — switch.norm.funcs.flex","text":"switch.norm.funcs.flex","code":""},{"path":"/reference/switch.norm.funcs.flex.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Switch normalization funcsions in a flexible way — switch.norm.funcs.flex","text":"","code":"switch.norm.funcs.flex(norm.list = c(\"NN\", \"MN\", \"QN\"), norm.funcs = NULL) #> [1] \"nn.norm\"    \"med.norm\"   \"quant.norm\""},{"path":"/reference/switch.norm.funcs.html","id":null,"dir":"Reference","previous_headings":"","what":"Switch Normalization Functions — switch.norm.funcs","title":"Switch Normalization Functions — switch.norm.funcs","text":"Switch normalization method name function name, running normalization procedure","code":""},{"path":"/reference/switch.norm.funcs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Switch Normalization Functions — switch.norm.funcs","text":"","code":"switch.norm.funcs(norm.list = c(\"NN\", \"MN\", \"QN\", \"VSN\"), norm.funcs = NULL)"},{"path":"/reference/switch.norm.funcs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Switch Normalization Functions — switch.norm.funcs","text":"norm.list Switch build-normalization methods function names, including \"NN\", \"MN\", \"QN\", \"VSN\". norm.funcs New functions user can create .","code":""},{"path":"/reference/switch.norm.funcs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Switch Normalization Functions — switch.norm.funcs","text":"list transforms normalization method name function name.","code":""},{"path":"/reference/switch.norm.funcs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Switch Normalization Functions — switch.norm.funcs","text":"switch.norm.funcs","code":""},{"path":"/reference/switch.norm.funcs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Switch Normalization Functions — switch.norm.funcs","text":"","code":"switch.norm.funcs(norm.list = c(\"NN\", \"MN\", \"QN\"), norm.funcs = NULL) #> [1] \"nn.norm\"    \"med.norm\"   \"quant.norm\""},{"path":"/reference/tabulate.ext.err.func.html","id":null,"dir":"Reference","previous_headings":"","what":"Tabulate.ext.err.func — tabulate.ext.err.func","title":"Tabulate.ext.err.func — tabulate.ext.err.func","text":"assistant function used calculate error rate classification.","code":""},{"path":"/reference/tabulate.ext.err.func.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tabulate.ext.err.func — tabulate.ext.err.func","text":"","code":"tabulate.ext.err.func(pred.obj, obs.grp)"},{"path":"/reference/tabulate.ext.err.func.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tabulate.ext.err.func — tabulate.ext.err.func","text":"pred.obj predicted group classes obs.grp actual group classes","code":""},{"path":"/reference/tabulate.ext.err.func.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tabulate.ext.err.func — tabulate.ext.err.func","text":"error rate predicted classification","code":""},{"path":"/reference/tabulate.ext.err.func.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tabulate.ext.err.func — tabulate.ext.err.func","text":"","code":"pred.obj = c(\"V\", \"V\", \"V\", \"V\", \"E\", \"V\", \"E\", \"E\", \"E\", \"E\") obs.grp = c(\"V\", \"V\", \"V\", \"V\", \"V\", \"E\", \"E\", \"E\", \"E\", \"E\") tabulate.ext.err.func(pred.obj, obs.grp) #> [1] 0.2"},{"path":"/reference/uhdata.pl.html","id":null,"dir":"Reference","previous_headings":"","what":"The uniformly-handled probe-level dataset,\r\n10 probes for each unique probe — uhdata.pl","title":"The uniformly-handled probe-level dataset,\r\n10 probes for each unique probe — uhdata.pl","text":"five percent random subset uniformly-handled probe-level dataset, 10 probes per unique probe. expressions log2 scale without background adjustmnet. dataset consists 181 unique probes, 6 negatively biological control probes Agilent array platform: \"NC2_00079215\", \"NC1_00000215\", \"NC1_00000197\", \"NC2_00122731\", \"NC2_00092197\", \"NC2_00106057\". sample IDs (column names) ending \"E\" \"V\" used indicate whether sample endometrial ovarian tumor sample. 96 endometrial 96 ovarian tumor samples.","code":""},{"path":"/reference/uhdata.pl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The uniformly-handled probe-level dataset,\r\n10 probes for each unique probe — uhdata.pl","text":"","code":"uhdata.pl"},{"path":"/reference/uhdata.pl.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"The uniformly-handled probe-level dataset,\r\n10 probes for each unique probe — uhdata.pl","text":"data matrix 1810 rows (probes) 192 columns (samples).","code":""},{"path":"/reference/uni.handled.simulate.html","id":null,"dir":"Reference","previous_headings":"","what":"Classification analysis of uniformly-handled data — uni.handled.simulate","title":"Classification analysis of uniformly-handled data — uni.handled.simulate","text":"Perform classification analysis uniformly-handled data re-assigning samples training test set. details can found Qin et al. (see reference).","code":""},{"path":"/reference/uni.handled.simulate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Classification analysis of uniformly-handled data — uni.handled.simulate","text":"","code":"uni.handled.simulate(   seed,   N,   biological.effect,   norm.list = c(\"NN\", \"QN\"),   class.list = c(\"PAM\", \"LASSO\"),   norm.funcs = NULL,   class.funcs = NULL,   pred.funcs = NULL )"},{"path":"/reference/uni.handled.simulate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Classification analysis of uniformly-handled data — uni.handled.simulate","text":"seed integer used initialize pseudorandom number generator. N number simulation runs. biological.effect estimated biological effect dataset. dataset must rows probes columns samples. norm.list list strings normalization methods compared simulation study. built-normalization methods includes \"NN\", \"QN\", \"MN\", \"VSN\" \"Normalization\", \"Quantile Normalization\", \"Median Normalization\", \"Variance Stabilizing Normalization\". User can provide list normalization methods given functions supplied (also see norm.funcs). class.list list strings classification methods compared simulation study. built-classification methods \"PAM\" \"LASSO\" \"prediction analysis microarrays\" \"least absolute shrinkage selection operator\". User can provide list classification methods given correponding model-building predicting functions supplied (also see class.funcs pred.funcs). norm.funcs list strings names user-defined normalization method functions, order norm.list, excluding built-normalization methods. class.funcs list strings names user-defined classification model-building functions, order class.list, excluding built-classification methods. pred.funcs list strings names user-defined classification predicting functions, order class.list, excluding built-classification methods.","code":""},{"path":"/reference/uni.handled.simulate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Classification analysis of uniformly-handled data — uni.handled.simulate","text":"benchmark analysis results -- list training--test-set splits, fitted models, misclassification error rates across simulation runs: assign_store random training--test-set splits model_store models combination normalization methods classification methods error_store internal external misclassification error rates combination normalization methods classification methods","code":""},{"path":"/reference/uni.handled.simulate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Classification analysis of uniformly-handled data — uni.handled.simulate","text":"analysis uniformly-handled dataset consists following main steps: (1) randomly split data training set test set, balanced sample group interest (2) preprocess training data test data (3) build classifier using preprocessed training data (4) assess mislcassification error rate classifier using preprocessed test data analysis repeated N random splits training set test set. Data preprocessing (2) includes three steps: log2 transformation, normalization training data frozen normalization test data, probe-set summarization using median. Normalization methods specified norm.list. Classifier building (3) includes choosing tuning parameter method using five-fold cross-validation measuring classifier accuarcy using misclassification error rate. Classification methods specified class.list error rate evaluated external validation test data cross-validation training data. user-defined normalization method classification method, please refer vignette.","code":""},{"path":"/reference/uni.handled.simulate.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Classification analysis of uniformly-handled data — uni.handled.simulate","text":"Qin LX, Huang HC, Begg CB. Cautionary note cross validation molecular classification. Journal Clinical Oncology. 2016.","code":""},{"path":"/reference/uni.handled.simulate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Classification analysis of uniformly-handled data — uni.handled.simulate","text":"","code":"if (FALSE) { biological.effect <- estimate.biological.effect(uhdata = uhdata.pl)  ctrl.genes <- unique(rownames(uhdata.pl))[grep(\"NC\", unique(rownames(uhdata.pl)))]  biological.effect.nc <- biological.effect[!rownames(biological.effect) %in% ctrl.genes, ]  uni.handled.results <- uni.handled.simulate(seed = 1, N = 3,                                             biological.effect = biological.effect.nc,                                             norm.list = c(\"NN\", \"QN\"),                                             class.list = c(\"PAM\", \"LASSO\")) }"},{"path":"/reference/vs.norm.html","id":null,"dir":"Reference","previous_headings":"","what":"Variance stabilizing normalization — vs.norm","title":"Variance stabilizing normalization — vs.norm","text":"Normalize training dataset vsn store fitted vsn model training dataset reference frozen variance stabilizing normalize test dataset. Also two options available: normalize training dataset frozen normalize test dataset, vise versa.","code":""},{"path":"/reference/vs.norm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Variance stabilizing normalization — vs.norm","text":"","code":"vs.norm(train = NULL, test = NULL, ref.dis = NULL)"},{"path":"/reference/vs.norm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Variance stabilizing normalization — vs.norm","text":"train training dataset variance stabilizing normalized. dataset must rows probes columns samples. can left unspecified ref.dis suppied frozen normalize test set. test test dataset frozen variance stabilizing normalized. dataset must rows probes columns samples. number rows must equal number rows training set. default, test set specified (test = NULL) frozen normalization performed. ref.dis reference distribution frozen variance stabilizing normalize test set previously normalized training set. required train supplied. default, ref.dis = NULL.","code":""},{"path":"/reference/vs.norm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Variance stabilizing normalization — vs.norm","text":"list two datasets one reference distribution: train.mn normalized training set test.fmn frozen normalized test set, test set specified ref.dis reference distribution","code":""},{"path":"/reference/vs.norm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Variance stabilizing normalization — vs.norm","text":"Wolfgang Huber, Anja von Heydebreck, Holger Sueltmann, Annemarie Poustka Martin Vingron. Variance Stabilization Applied Microarray Data Calibration Quantification Differential Expression. Bioinformatics 18, S96-S104 (2002).","code":""},{"path":"/reference/vs.norm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Variance stabilizing normalization — vs.norm","text":"","code":"if (FALSE) { set.seed(101) group.id <- substr(colnames(nuhdata.pl), 7, 7) train.ind <- colnames(nuhdata.pl)[c(sample(which(group.id == \"E\"), size = 64),                                sample(which(group.id == \"V\"), size = 64))] train.dat <- nuhdata.pl[, train.ind] test.dat <- nuhdata.pl[, !colnames(nuhdata.pl) %in% train.ind]  # normalize only training set data.vsn <- vs.norm(train = train.dat) str(data.vsn)  # normalize training set and frozen normalize test set data.vsn <- vs.norm(train = train.dat, test = test.dat) str(data.vsn)  # frozen normalize test set with reference distribution ref <- vs.norm(train = train.dat)$ref.dis data.vsn <- vs.norm(test = test.dat, ref.dis = ref) str(data.vsn) }"}]
